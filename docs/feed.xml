<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2021-01-02T17:41:19+08:00</updated><id>/feed.xml</id><title type="html">Lament’s Mage Tower</title><subtitle>Neutral, sometimes chaotic neutral</subtitle><entry><title type="html">JVM-RuntimeDataArea</title><link href="/JVM-Runtime-Data-Area" rel="alternate" type="text/html" title="JVM-RuntimeDataArea" /><published>2020-12-28T00:00:00+08:00</published><updated>2020-12-28T00:00:00+08:00</updated><id>/JVM-Runtime-Data-Area</id><content type="html" xml:base="/JVM-Runtime-Data-Area">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;《Java虚拟机规范》定义了如下几个运行时数据区：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lament-z.com/assets/images/JVM/runtime-data-area-v1.jpg&quot; alt=&quot;RT Data Areas Overview&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中一些区域随着线程的启动和结束而创建和销毁，另一部分则随着JVM的启动而一直存在到JVM关闭。&lt;/p&gt;

&lt;h2 id=&quot;使用方法&quot;&gt;使用方法&lt;/h2&gt;

&lt;p&gt;一边画图一边看，画一块看一块。
  过完一遍之后，擦了重来，哪里忘了看哪里。&lt;/p&gt;

&lt;h2 id=&quot;详解&quot;&gt;详解&lt;/h2&gt;

&lt;p&gt;下图可以更直观的区分不同数据区域:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lament-z.com/assets/images/JVM/runtime-data-area-v2.jpg&quot; alt=&quot;RT Data Areas with Thread&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从第二张图可以清晰的看出，虚拟机栈(JVM Stack)、本地方法栈(Native Stack)、以及程序计数器(The Program Counter Register)与线程共生共灭。&lt;/p&gt;

&lt;p&gt;而堆（Heap）和方法区（Method Area 也被称作非堆）则被所以线程共享。&lt;/p&gt;

&lt;p&gt;接下来逐个介绍每个区域的功能，按照是否线程隔离，先从与线程共生共灭的几种说起。&lt;/p&gt;

&lt;h3 id=&quot;程序计数器-the-program-counter-register&quot;&gt;程序计数器 (The Program Counter Register)&lt;/h3&gt;

&lt;p&gt;程序计数器，之后简称为PC Register，简单的说就是记录当前线程执行的字节码所在行号的一小块内存，如果线程执行的是本地方法(Native Method)则记录undefined，其生命周期与线程相同。&lt;/p&gt;

&lt;p&gt;JVM的多线程是“分片”式实现：在任意确定时刻，一个处理器(多核CPU则是其中一个核)只都只执行一个线程中的指令（看作一个片）。并发只是不断在各个分片上切换的”假象”。而每个线程的PC Register就是用来保证线程切换后可以正确恢复的关键。&lt;/p&gt;

&lt;p&gt;PC Register的工作就是通过改变PC Register存储的值来选取需要执行的下一条字节码指令。
  程序控制流，如分支、循环、跳转、异常处理、线程恢复等等都依赖这个指示器。&lt;/p&gt;

&lt;h4 id=&quot;内存&quot;&gt;内存&lt;/h4&gt;

&lt;p&gt;其内存大小足够持有一个”return Address”或者是一个指定系统的Native pointer，具体到不同版本JVM的实现里是多大没关心过。&lt;/p&gt;

&lt;h4 id=&quot;异常&quot;&gt;异常&lt;/h4&gt;

&lt;p&gt;唯一一个“规范”中没有定义内存异常的区域。&lt;/p&gt;

&lt;h3 id=&quot;虚拟机栈-jvm-stack&quot;&gt;虚拟机栈 (JVM Stack)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;这部分摘自《深入理解JAVA虚拟机(第三版)》。 &lt;br /&gt;
 虚拟机栈(VM Stack)描述的是Java方法执行的线程内存模型:  &lt;br /&gt;
 每个方法被执行的时候，Java虚拟机都会同步创建一个帧(StackFrame)用于存储局部变量表(Local Variable Array)、操作数栈(Operand Stack)、动态连接、方法出口等信息。
 每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;啥意思呢，先看下图，主要是右半部分，懒得单独做一张 VM Stack 的图了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lament-z.com/assets/images/JVM/RuntimeDataArea-details.jpg&quot; alt=&quot;RT Data Areas with vm stack details&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每当一个新线程启动的时候，JVM就会给这个线程创建一个 VM Stack，而VM Stack把线程的状态存储在栈帧(Stack Frame)中，JVM对 VM Stack 的直接操作就俩：入栈，出栈（Because the Java Virtual Machine stack is never manipulated directly except to push and pop frames, frames may be heap allocated.）。&lt;/p&gt;

&lt;p&gt;无论是我们写的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.out.println(&quot;Hello World&quot;);&lt;/code&gt; 还是别的什么方法，都是基于这个模型完成的。&lt;/p&gt;

&lt;p&gt;”Stack Frame“ ，包括“JVM执行方法时都发生了啥”这里暂时不展开，回头单独开一篇顺便打包上“递归”一起说。&lt;/p&gt;

&lt;p&gt;万一我鸽太久，也可以先看看《Inside the Java Virtual Machine》中的&lt;a href=&quot;https://www.artima.com/insidejvm/ed2/jvm8.html&quot;&gt;The Java Stack&lt;/a&gt;这一节，讲述的非常清晰。&lt;/p&gt;

&lt;h4 id=&quot;内存-1&quot;&gt;内存&lt;/h4&gt;

&lt;p&gt;该区域中内存无需连续。&lt;/p&gt;

&lt;h4 id=&quot;异常-1&quot;&gt;异常&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;当线程申请 VM Stack 的深度超过的规定时，抛 &lt;strong&gt;&lt;em&gt;StackOverflowError&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当 VM Stack 为可拓展型时，线程需要动态扩展自己的 VM Stack，但空余内存不足时；或者当空余内存不足以初始化线程的 VM Stack 时，抛 &lt;strong&gt;&lt;em&gt;OutOfMemoryError&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;本地方法栈-native-stack&quot;&gt;本地方法栈 (Native Stack)&lt;/h3&gt;

&lt;p&gt;跟VM Stack作用差不多，只不过是调用Native方法。
  异常情况也是类似。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;说完了线程隔离的区域，来看看共享的区域：Heap &amp;amp; Method Area。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;堆-heap&quot;&gt;堆 (Heap)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;The heap is the run-time data area from which memory for all class instances and arrays is allocated.   – From JVMS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所有的类的实例，数组啥的都在堆(Heap)上分配。
  提到Heap就免不了说一嘴分代，什么新生代老年代永久代，包括元空间blabla，这些是基于“分代收集理论”or某些JVM具体实现引出的说法，Heap在本篇仅限于“JVMS中规定的Heap”这么一个抽象模型。&lt;/p&gt;

&lt;h4 id=&quot;内存-2&quot;&gt;内存&lt;/h4&gt;

&lt;p&gt;Heap可以是固定大小，也可以是可扩展式的。
  通常遇到的都是可扩展的，通过-Xmx(maximum heap size ) -Xms(minimum heap size，也称为初始 Heap size)来设定其大小。&lt;/p&gt;

&lt;p&gt;关于某些特定的JVM的这类参数啦、这类参数选项都有啥啦、它们的含义啥的可以参考Oracle的&lt;a href=&quot;https://docs.oracle.com/cd/E21764_01/web.1111/e13814/jvm_tuning.htm#PERFM150&quot;&gt;Tuning Java Virtual Machines&lt;/a&gt;文档。&lt;/p&gt;

&lt;p&gt;关于TLAB(Thread Local Allocation Buffer):&lt;/p&gt;

&lt;p&gt;《深入理解JAVA虚拟机(第三版)》里面提到了，为了提升对象分配时效率，Heap中会划分出多个被线程私有的分配缓冲区，这个缓冲区就是TLAB，里面存的依然是对象的实例或Array。说白了就是从大Heap里分几个小Heap给Thread们拿去用，只是优化的手段，Heap还是Heap。&lt;/p&gt;

&lt;h4 id=&quot;异常-2&quot;&gt;异常&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;如果Heap中剩余内存不够分配给实例or数组，并且也没更多的内存让Heap完成扩展时，抛&lt;strong&gt;&lt;em&gt;OutOfMemoryError&lt;/em&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;方法区-method-area&quot;&gt;方法区 (Method Area)&lt;/h3&gt;

&lt;p&gt;方法区 (Method Area，很多资料也用非堆来将它与堆进行区分)用来存储被JVM加载的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;类型信息 TypeInformation&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;常量池 The Constant Pool&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;域信息 Field Information&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法信息 Method Information&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类变量 Class Variables  &lt;br /&gt;
  鉴于我接触的很多人都不这么叫，很多书上也不这么写，稍微解释下啥是类变量。
  举个例子，比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Integer.MAX_VALUE&lt;/code&gt;中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAX_VALUE&lt;/code&gt;这种作为类属性之一，并且被&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt;修饰(是不是public无所谓)，当然还自带初始值的，就是类变量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;各种引用等等&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体细节单独展开。&lt;/p&gt;

&lt;p&gt;这里的部分翻译参考了&lt;a href=&quot;https://www.ituring.com.cn/article/491755&quot;&gt;Java 中 field 和 variable 区别及相关术语解释&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;内存-3&quot;&gt;内存&lt;/h4&gt;

&lt;p&gt;规范中对该区域规定也比较宽松，不需要内存连续，可以是固定大小的也可以是可扩展的。&lt;/p&gt;

&lt;p&gt;还有之前提到的“分代理论”，以前一些JVM按照他们自己的分代设计，用永久代实现了方法区。
  叫永久可能是这部分存贮的都是些比较”固定”的东西，但是不代表&lt;strong&gt;&lt;em&gt;永久代 == 方法区&lt;/em&gt;&lt;/strong&gt;，也不代表该区域就绝对不进行内存回收。&lt;/p&gt;

&lt;h4 id=&quot;异常-3&quot;&gt;异常&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;无法满足新的内存分配需求时,抛&lt;strong&gt;&lt;em&gt;OutOfMemoryError&lt;/em&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;运行时常量区-run-time-constant-pool&quot;&gt;运行时常量区 (Run-Time Constant Pool)&lt;/h3&gt;

&lt;p&gt;它是方法区的一部分，规范规定当JVM创建一个类或者接口时，就为该类或对象构建一个运行时常量池。&lt;/p&gt;

&lt;p&gt;写了半天都不太满意，要么不够清楚，要么不够简洁，先挂着&lt;a href=&quot;https://blog.jamesdbloom.com/JVMInternals.html#constant_pool&quot;&gt;别人的吧&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;内存-4&quot;&gt;内存&lt;/h4&gt;

&lt;p&gt;它的内存是从方法区的内存里分配的，受到方法区本身内存大小的限制。&lt;/p&gt;

&lt;h4 id=&quot;异常-4&quot;&gt;异常&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;当创建类(Class)或者接口(Interface)时，运行时常量池需要的内存大于方法区剩余的空余内存,抛&lt;strong&gt;&lt;em&gt;OutOfMemoryError&lt;/em&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;补充说明&quot;&gt;补充说明&lt;/h3&gt;

&lt;h4 id=&quot;heap-和-method-area-的逻辑关系&quot;&gt;Heap 和 Method Area 的逻辑关系。&lt;/h4&gt;

&lt;p&gt;可以看看&lt;a href=&quot;https://www.artima.com/insidejvm/ed2/jvm6.html&quot;&gt;The Heap&lt;/a&gt;下面画的几种关系图。 我就先不画了，偷个懒，后面单独写Heap和MethodArea的时候再说。&lt;/p&gt;

&lt;h4 id=&quot;直接内存-direct-memory&quot;&gt;直接内存 (Direct Memory)&lt;/h4&gt;

&lt;p&gt;该内存区域不属于运行时数据区(Runtime Data Areas)，也不在《Java虚拟机规范》的定义中。
  比如开发者可以通过JNI或者NIO的ByteBuffer来调用malloc.&lt;/p&gt;

&lt;h4 id=&quot;nio&quot;&gt;NIO&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;这部分摘自《深入理解JAVA虚拟机(第三版)》。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区 (Buffer)的I/O方式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;这么做避免了在Java堆和Native堆中来回复制数据，能在一些场景中显著提高性能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.geeksforgeeks.org/java-virtual-machine-jvm-stack-area/&quot;&gt;Java Virtual Machine (JVM) Stack Area&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5&quot;&gt;JVMS-Run-Time Data Areas&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/34907497/&quot;&gt;深入理解JAVA虚拟机(第三版)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.baeldung.com/native-memory-tracking-in-jvm&quot;&gt;Native Memory Tracking in JVM&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.artima.com/insidejvm/ed2/index.html&quot;&gt;Inside the Java Virtual Machine&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="Scroll" /><summary type="html">概述</summary></entry><entry><title type="html">JVM Overview</title><link href="/JVM-Overview" rel="alternate" type="text/html" title="JVM Overview" /><published>2020-12-26T00:00:00+08:00</published><updated>2020-12-26T00:00:00+08:00</updated><id>/JVM-Overview</id><content type="html" xml:base="/JVM-Overview">&lt;p&gt;前一阵微信提醒我不要浪费订阅号资源。&lt;/p&gt;

&lt;p&gt;于是就顺手画了一张图回忆JVM，顺便借着这个机会把JVM的知识点系统化一下。&lt;/p&gt;

&lt;p&gt;因为当时先发的微信订阅号，所以这里的内容会跟订阅号略有不同。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lament-z.com/assets/images/JVM/JVM-Overview.jpg&quot; alt=&quot;JVM Overview&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;用法&quot;&gt;用法&lt;/h2&gt;

&lt;p&gt;我特别不擅长背东西，通常需要借助一些手段来帮助记忆。&lt;/p&gt;

&lt;p&gt;对于JVM这种，我用的是看图说话+推理式记忆法，核心思路就是按照逻辑去记忆和推理细节。&lt;/p&gt;

&lt;p&gt;当JVM的模型结构还不熟悉时，可以一边口述逻辑关系，一边画出这个图。&lt;/p&gt;

&lt;p&gt;当可以熟练的画出该图后，可以尝试分模块口述每个模块的功能，甚至每个模块内部的细分结构。&lt;/p&gt;

&lt;p&gt;每一层只回忆当前层的知识，深入讨论放在合适的层面，比如overview时不去回忆什么方法区，只想RuntimeDataArea。&lt;/p&gt;

&lt;p&gt;这样可以在脑内建立一个符合JVM模型/设计逻辑的知识体系，相当于一个索引一样。&lt;/p&gt;

&lt;p&gt;当工作/面试时遇到某些零散知识点的时候，研究明白之后就可以相对精准的补充到合适的维度。&lt;/p&gt;

&lt;p&gt;不至于重演之前用完就忘了的尴尬。&lt;/p&gt;

&lt;h2 id=&quot;一个面试题告诉你什么叫鱼的记忆&quot;&gt;一个面试题告诉你什么叫鱼的记忆&lt;/h2&gt;

&lt;p&gt;这简直就是我鱼的记忆一个典型例子。&lt;/p&gt;

&lt;p&gt;我学习JVM最初主要通过《深入理解JAVA虚拟机》这本书，翻来覆去的看了好多遍，然而昨天朋友发来一道从该书提取出的面试题大致如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
        String str1 = new StringBuilder(&quot;lament&quot;).append(&quot;z&quot;).toString();
        System.out.println(str1);
        System.out.println(str1.intern());
        System.out.println(str1 == str1.intern());


        System.out.println();

        String str2 = new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString();
        System.out.println(str2);
        System.out.println(str2.intern());
        System.out.println(str2 == str2.intern());


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我对此完全没有印象，打开书特意找了一下才发现确实是介绍方法区那一节的一个例子。&lt;/p&gt;

&lt;p&gt;这个例子本身非常有趣，但是其实作为面试题（尤其是问为什么最后一行的输出是false）来考察是不是看过这本书，对我这种鱼的记忆简直太过分了。&lt;/p&gt;

&lt;p&gt;需要注意的是这个例子是与环境强相关的，如果你想自己重现false的情况，可以使用 &lt;em&gt;** Oracle JDK7u / OpenJDK7u HotSpot VM **&lt;/em&gt; 。&lt;/p&gt;

&lt;p&gt;不然你很可能看到两个true XD。&lt;/p&gt;

&lt;p&gt;当然如果你看到这里突然对“字符串常量池”和“String#intern”产生兴趣了，可以看看美团的这一篇&lt;a href=&quot;https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html&quot;&gt;解析&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/34907497/&quot;&gt;深入理解JAVA虚拟机(第三版)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&quot;&gt;The Java® Virtual Machine Specification&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="Scroll" /><summary type="html">前一阵微信提醒我不要浪费订阅号资源。</summary></entry><entry><title type="html">好用的工具们(一)</title><link href="/dev-tools-1" rel="alternate" type="text/html" title="好用的工具们(一)" /><published>2020-07-23T00:00:00+08:00</published><updated>2020-07-23T00:00:00+08:00</updated><id>/dev-tools-1</id><content type="html" xml:base="/dev-tools-1">&lt;h1 id=&quot;好用的工具们&quot;&gt;好用的工具们&lt;/h1&gt;

&lt;h2 id=&quot;notice&quot;&gt;NOTICE&lt;/h2&gt;

&lt;p&gt;这个系列主要是罗列一些我很喜欢的工具们（多数为开发时使用的工具），进行简单的介绍，并分享一些自己的使用心得。&lt;/p&gt;

&lt;p&gt;大部分工具都有详细的文档，所以关于安装啥的不会详细列出，仅涉及一些常见的坑点和我认为需要记住的点。&lt;/p&gt;

&lt;p&gt;无特殊说明系统环境均为 macOS Catalina Version 10.15.4。&lt;/p&gt;

&lt;h3 id=&quot;port-443-connection-refused--其他连接失败&quot;&gt;port 443: Connection refused || 其他连接失败&lt;/h3&gt;

&lt;p&gt;这个会是国内用户非常常见的错误。基本上就是网络相关的问题，有以下几种解决方案:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;直接在浏览器中访问脚本文件，下载到本地然后安装。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;浏览器中都打不开，挂vpn&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;没有vpn，找找别的源，找一个换上用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;macOS的command line tool不符合要求，使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xcode-select --install&lt;/code&gt;重装，或者注册个开发者账号自行下载安装对应版本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改host，不建议使用该方法，或者你记得改回去。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改dns，也不建议，或者记得改回去。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;homebrew&quot;&gt;&lt;a href=&quot;https://brew.sh/&quot;&gt;Homebrew&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;神器.&lt;/p&gt;

&lt;h3 id=&quot;brew-everything&quot;&gt;brew everything&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  brew install [xxx]
  brew cask install [xxx]
  ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;brew-services&quot;&gt;brew services&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # 列出所有 brew 管理的服务
  brew services

  # 帮助，省的记其他命令
  brew services -h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;其他tips&quot;&gt;其他tips&lt;/h3&gt;

&lt;p&gt;Homebrew 会将软件包安装到独立目录，并将其文件软链接至 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/usr/local&lt;/code&gt;。 这个官网首页就写着。&lt;/p&gt;

&lt;p&gt;这些软件包默认安装在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/usr/local/Cellar or /usr/local/Caskroom or /usr/local/...&lt;/code&gt;,你也可以自己指定安装位置。&lt;/p&gt;

&lt;p&gt;避免使用sudo.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.brew.sh/&quot;&gt;更多请查询文档&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;oh-my-zsh&quot;&gt;&lt;a href=&quot;https://ohmyz.sh/&quot;&gt;oh-my-zsh&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;神器！&lt;/p&gt;

&lt;p&gt;oh-my-zsh相对于zsh已经非常人性化了，但实际上对于新手来说还是会遇到很多问题。&lt;/p&gt;

&lt;h3 id=&quot;新人上手&quot;&gt;新人上手&lt;/h3&gt;

&lt;p&gt;根据我安利别人之后的反馈，我总结了一下新人上手的流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;主题不要太过花里胡哨。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;插件一个一个往里添加，不要一次性看着好像哪个插件都想用就直接添加一堆。&lt;/p&gt;

    &lt;p&gt;阅读插件的&lt;a href=&quot;https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins&quot;&gt;文档&lt;/a&gt;可以帮你几分钟内了解插件的功能和用法，比你百度乱搜强得多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;活用别名&lt;/p&gt;

    &lt;p&gt;至于是否“滥用”，就见仁见智了，反正我自己是已经滥用了，很多命令原本长啥样都不记得了，缺点是面试的时候别人问起来只记得别名，或者切换到服务器上的时候想不起来命令。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;卡slow&quot;&gt;卡/slow&lt;/h3&gt;

&lt;p&gt;对于国内用户而言，卡主要是网络问题。&lt;/p&gt;

&lt;p&gt;然而zsh卡的原因很多，尤其是你一万个插件一起加载，那卡的原因简直花里胡哨了，对于我这个不太了解bash的人来说，调试这东西简直就是噩梦。&lt;/p&gt;

&lt;h4 id=&quot;自行调试&quot;&gt;自行调试&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;zsh调试命令
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# x = xtrace  v = verbose
zsh -xv

# 查看启动时间
/usr/bin/time zsh -i ic exit;

# 查看zsh启动时都干了啥，并且每一步花费多少时间
# 在.zshrc 的头尾分别添加 zmodload zsh/zprof | zprof
# 这样每次打开一个新终端的时候会以列表的形式展示启动信息。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;调试流程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以参考这篇&lt;a href=&quot;https://blog.jonlu.ca/posts/speeding-up-zsh&quot;&gt;blog&lt;/a&gt;，我就不献丑了。&lt;/p&gt;

&lt;h4 id=&quot;插件管理器&quot;&gt;插件管理器&lt;/h4&gt;

&lt;p&gt;zsh慢主要是: 1.启动慢，2.prompt慢&lt;/p&gt;

&lt;p&gt;为了解决情况1，所以又出现了管理器。&lt;/p&gt;

&lt;p&gt;然而管理器又是一个大坑。&lt;/p&gt;

&lt;p&gt;这里只推荐一款&lt;a href=&quot;https://github.com/zdharma/zinit&quot;&gt;Zinit&lt;/a&gt;，因为这款插件有延时加载的实现，就比如&lt;strong&gt;&lt;em&gt;thefuck&lt;/em&gt;&lt;/strong&gt;（这个后面会推荐）插件，并不需要一打开终端就启动他。&lt;/p&gt;

&lt;p&gt;然而Zinit自己本身因为功能太多了，也是个巨坑，学到够用即可，不是时间特别充裕不建议深挖。&lt;/p&gt;

&lt;h4 id=&quot;异步主题&quot;&gt;异步主题&lt;/h4&gt;

&lt;p&gt;非要花里胡哨的主题，又不想很慢，那就只能用异步主题了。&lt;/p&gt;

&lt;p&gt;异步主题会把git信息统计之类比较耗时的操作丢到后台异步处理，处理完了再刷新prompt，就不用等了。&lt;/p&gt;

&lt;p&gt;oh-my-zsh自带的所有主题都不是异步主题…真的换了的话，主题文件夹就可以全删了。&lt;/p&gt;

&lt;p&gt;这里只推荐一个&lt;a href=&quot;https://github.com/romkatv/powerlevel10k#oh-my-zsh&quot;&gt;
powerlevel10k&lt;/a&gt;，因为这个有国内源，中文分享也多。&lt;/p&gt;

&lt;h4 id=&quot;其他&quot;&gt;其他&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;烂大街方法:主要解决prompt慢
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git config --global oh-my-zsh.hide-status 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;incr插件补全慢&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;自动补全速度慢，这个上面两种方法都解决不了这个问题(大概?)。&lt;/p&gt;

&lt;p&gt;并且我个人不适应 incr 插件的一些操作习惯，尤其是复制粘贴命令的时候。&lt;/p&gt;

&lt;p&gt;这里给出一个&lt;a href=&quot;https://raw.githubusercontent.com/ggggle/myEnv/master/ubuntu/.oh-my-zsh/plugins/incr/incr-0.2.zsh&quot;&gt;别人的魔改版&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个魔改版我用了很久了，我自己的就不放了，bug略多，每次玩坏了我都是用这个恢复的。&lt;/p&gt;

&lt;p&gt;替换掉原来的 incr-0.2.zsh 即可。目录在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.oh-my-zsh/plugins/incr&lt;/code&gt; 。&lt;/p&gt;

&lt;h3 id=&quot;插件推荐&quot;&gt;插件推荐&lt;/h3&gt;

&lt;p&gt;只推一个&lt;a href=&quot;https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/thefuck&quot;&gt;thefuck&lt;/a&gt;，非常好用。&lt;/p&gt;

&lt;p&gt;毕竟每个人使用场景不同，oh-my-zsh 这类用到最后一定会越来越私人化的工具，我个人观点从来都是适合自己就好，所以其他插件不做推荐。&lt;/p&gt;

&lt;h2 id=&quot;iterm-2&quot;&gt;&lt;a href=&quot;https://www.iterm2.com/&quot;&gt;iTerm 2&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;由于之前误操作把文件洗了，我也不记得关于iTerm2我要说啥了。&lt;/p&gt;

&lt;p&gt;多屏幕的花记得Command+D快捷键 配合 &lt;a href=&quot;https://www.spectacleapp.com/&quot;&gt;Spectacle&lt;/a&gt; 非常方便。&lt;/p&gt;

&lt;h2 id=&quot;sdkman&quot;&gt;&lt;a href=&quot;https://sdkman.io/&quot;&gt;sdkman&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;好歹我是个java后端，最后推荐个sdkman，也是神器级命令行工具。&lt;/p&gt;

&lt;h3 id=&quot;命令解释&quot;&gt;命令解释&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sdk install &amp;lt;candidate&amp;gt; [version] [local-path]

  # 其中 &amp;lt;candidate&amp;gt; 的可选项可通过如下命令获取 ,按Q可退出。
  sdk list

  # 其中 version 的可选项通过如下命令获取，不写则下载最新版本，以java为例
  sdk java list

  # 安装位置就不解释了，不写就默认
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;use&quot;&gt;use&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # use可以在 *当前终端* 临时切换某个jdk，即使该jdk不存在，他也会自动去下载并切换过去。
  sdk use &amp;lt;candidate&amp;gt; [version]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;jdk版本不认识&quot;&gt;JDK版本不认识&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://sdkman.io/jdks&quot;&gt;看这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;文档找不到&quot;&gt;文档找不到&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://sdkman.io/usage&quot;&gt;他只是换了个单词叫Usage&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="alchemy-lab" /><summary type="html">好用的工具们</summary></entry><entry><title type="html">2019读过的书</title><link href="/2019booklist" rel="alternate" type="text/html" title="2019读过的书" /><published>2020-01-02T00:00:00+08:00</published><updated>2020-01-02T00:00:00+08:00</updated><id>/2019booklist</id><content type="html" xml:base="/2019booklist">&lt;h2 id=&quot;小野不是妹纸的2019书单&quot;&gt;小野不是妹纸的2019书单&lt;/h2&gt;

&lt;p&gt;2019之前真的很久没有读书了，之前的阅读基本都是在飞机上完成的，其他时间除了用来催眠的网络小说之外几乎什么都没读。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26836970/&quot;&gt;沙丘&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;小时候玩沙丘2000时入坑的，只零零散散的看过一些找到的盗版，记忆早已模糊不清，逛书店的时候偶遇了这套书，大概挣扎了5分钟之后就把三本一起抱回家了，花了两天时间一口气读完，酣畅淋漓，顺便就开启了今年的购书读书之旅。也不造回头搬家的时候会不会想砍死自己。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/27110281/&quot;&gt;自然赋予科技灵感&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;很好玩的科普读物，有很多照片和手绘图，书比较大，看完了还可以摆在客厅，既可以当摆件，客人无聊的时候也可以拿起来消磨时间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26936484/&quot;&gt;醉酒的植物学家&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;之前跟文山聊书的时候我兴致勃勃的推荐了这本书。文山戏称我是集实践与理论知识于一体的调酒师了XD，这本书的翻译很棒，阅读的时候毫无生涩感，也没有之前我查酒类资料时候各种翻译对不上号的模糊点，译者太强了！另外还看了一丢丢的原版，非常有趣（也可能是我自己笑点比较奇怪），虽然我不能完全读懂，尤其是专业名词。&lt;/p&gt;

    &lt;p&gt;无论是译者还是作者的其他书籍我现在都很感兴趣。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/3670287/&quot;&gt;Don’t shoot the dog 别毙了那只狗&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;入手的是台湾出版的繁体竖版，排版和繁体适应一下就好了，但是内容真的是啰里八嗦，翻来覆去的车轱辘话，愁死人了，已经放弃了，如果你想学如何利用响片训练自己的狗，这本书不建议买实体书，而且前五章都不用看，这部分只说了一件事情那就是通过强化正面反馈来训练你的狗，或者训练你身边一切你觉得需要训练的人。从第六章开始教你如何使用响片训练，一旦你开始觉得他又车轱辘的时候直接跳下一节就行了，没有任何损失。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/27102701/&quot;&gt;Option B 另一种选择&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;我已经想不起来购买这本书的理由了，通篇读下来并没有给我什么启发，唯一的感受就是，本来不就应该这样做吗，为什么这会是planB，可能适合心没我这么大的人来阅读，或者没有经历过“黑暗时期”的人提前建立一下心理防御机制？后者的话，买电子版就够了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/3682204/&quot;&gt;佐藤可士和的超整理术&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;买的时候是出于想通过这本书总结一套自己收拾屋子的方法论，然而这书讲的不是这个，至少没有拿收拾屋子举例，核心思想跟我之前读的《零秒工作》差不多，其实我更推荐后者，理由是从简单实践到领悟理论更好上手，而有持续的成就感，有点像刚开始学习编程一丢丢的成功也很快乐，缺点就是有点废纸，但纸在这套方法里很重要，至少我这么认为。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26869277/&quot;&gt;狗狗不是故意的&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://book.douban.com/subject/26043766/&quot;&gt;犬语教科书&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;第一次养狗的捡屎官们可以买来读一下，两本都很容易读，尤其是前一本是漫画的形式，很好玩，遇到自己家狗子熊起来的时候，你会自然的想起来漫画里的情节，然后就不那么容易生气和焦虑。
其实不知道自己适不适合养狗也可以先借来看看这两本书，书上的内容几乎百分之百是你将要遇到的情况。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/30761209/&quot;&gt;爱犬家庭医生：狗狗疾病快速诊断与处理&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;这本书我认为也可以作为养狗必备书，常见疾病的介绍和处理方式全都有了，虽然价格和药物名字可能不太符合国情，但是依然非常有用。还有个好处是遇到不靠谱的宠物医院和宠物店忽悠你的时候，你能迅速分辨出来，因为那帮忽悠懒得看书，张嘴就来。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26674343/&quot;&gt;容忍与自由&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://book.douban.com/subject/26968231/&quot;&gt;读书与做人&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;以上两本都是杂文集（也有说散文集，领会精神），对，就是哪个打牌、打牌、打牌的胡适…其实整套北理工出版的胡适文集我都买了，《四十自述》那一本也看了开头，对胡适回忆其母一生的那一篇感触颇深。 我个人阅读的重心会比较偏重去看他为人与处事的部分，读起来像是与至交好友聊天，而不是仰慕大师风采，另外比较神奇的一点感受是除了行文方式与现代略有差异之外，你几乎感受不到时代的差异，掩去名字把这两本书作为2019的新作品也没什么违和感。也不晓得这是作者太前卫还是这个时代的我们又开始螺旋了？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;茨威格全集&lt;a href=&quot;https://book.douban.com/subject/2154960/&quot;&gt;一个陌生女人的来信&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://book.douban.com/subject/27092641/&quot;&gt;人类群星闪耀时&lt;/a&gt;  &lt;br /&gt;
   这好像是什么电商节日的时候买的，早就想存一套了，我买的是上海译文出版社的，全集都买了，没有看完的唯一原因是，翻译的质量参差不齐，茨威格可是我的偶像啊，尤其是我们讨论的最多的《人类群星闪耀时》，当我在期待再一次酣畅淋漓的感受他作品的激情时，直接冒出来这么一句“于是，巴尔沃亚决定不再等待为征服那一片未知的大洋恳请西班牙派来的一千兵力到达，也不等候法官的到来。”–p12，简直就像你埋头于美食之中突然沙子就把牙硌了一样。
   更别提这个书本身的包装了，腰封和书外那层没卵用的皮我都是到手就扔掉的，结果扔完才发现，书的封面就没有显眼的书名了，找书只能靠颜色…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26897464/&quot;&gt;小岛经济学&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;很好玩的经济学科普读物，读完瞅啥都是鱼鱼～ 我读完之后再去观察和思考现实中的现象时终于有了除本能反应之外的思路，由于我个人没有经济学基础，而作者哪怕被翻译成中文也能感受到强烈的个人倾向性，所以不要把书里的内容直接当成真理哦，我依稀记得经济学是分派系的，而且还挺对立，谁也吵不赢谁。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/27104764/&quot;&gt;经济学通识课&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;这本书比起上一本来说就好难读了，虽然我把它列在了这里，但是我其实有看没有懂啦，第一章就是讲我们为什么要学经济学，我翻了两遍也没搞明白为啥，所以我只浅浅的过了一遍，唯一的感受就是，这些人发明/发现了好多奇怪的东西，然后出了好多书，最后都不保证好使。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/25910539/&quot;&gt;黑客与画家&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;如果读书的时候能看到这本书就好了，虽然译文版2014年才出，而我那时候已经变成酒吧老板了。非常酣畅淋漓的阅读体验，一个通宵读完的，（除了Lisp部分太陌生了），这也是一本神奇的书，但也是一本典型的聪明人写的书（当然作者本来就自称hacker），他试图让不那么聪明的人准确的理解他要表达的意思，这一意图特别明显，不可避免的就略微会感觉啰嗦，好处是你可以很直接的知道这个人出于什么原因，要采用这样的表达方式，最终说明了自己的观点。感谢译者&lt;a href=&quot;http://www.ruanyifeng.com/home.html&quot;&gt;阮一峰&lt;/a&gt;的出色工作，尤其感谢他愿意做这件事。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.qidian.com/info/3065119&quot;&gt;守望黎明号&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;非常喜欢的一本网络小说，作者写的很开心，我看的也很开心。博得之门，DND，生化危机，老头滚动条，金庸，幻想乡，甚至nnnn年前超火的《风姿物语》都很神奇的穿插在了一起，而且还为我童年最难过的事情画了另一个完美的句号。想当初我还买了糖葫芦，还不给林月如吃非要留给灵儿，结果凭什么灵儿要跟水魔兽这种怪物同归于尽啊，我就是让李逍遥这辈子啥也不干了变成水魔兽专杀工具也不要灵儿死啊，很感谢作者的脑洞，给了灵儿一个这么美的故事。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其他的想不太起来了，然后像什么数学分析这种。。又一下子写不完还是单独来吧，回头想到了再补充就好了&lt;/p&gt;</content><author><name></name></author><category term="magical-index" /><summary type="html">小野不是妹纸的2019书单</summary></entry><entry><title type="html">2019年终总结</title><link href="/in-the-end" rel="alternate" type="text/html" title="2019年终总结" /><published>2019-12-31T00:00:00+08:00</published><updated>2019-12-31T00:00:00+08:00</updated><id>/in-the-end</id><content type="html" xml:base="/in-the-end">&lt;h2 id=&quot;小野不是妹纸的2019的反思&quot;&gt;小野不是妹纸的2019的反思&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;

      &lt;p&gt;这个博客17年更新了没几次然后就没更了。 &lt;br /&gt;
当时我加入了一家公司，然后突然就开启了007的生活，每天睁开眼睛坐在桌子面前就开始上班，熬不住的时候躺下就睡就算是下班了，一直到2019年才结束了这样的生活。  &lt;br /&gt;
短短两年之后再看自己的博客感触完全不一样，于是决定把之前的内容删了，倒不是完全因为当初写的东西太傻，更主要的原因是那些东西没有太大价值，今天的自己来写的话，估计之前的几十篇我想要表达的东西一到两篇就写完了。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;言归正传，总结一下自己的2019.&lt;/p&gt;

&lt;p&gt;年初的时候我给自己定的2019年的目标浓缩为一个词，休息。&lt;/p&gt;

&lt;p&gt;现在回头再看总的来说还是很满足的，差不多完成度达到了90%左右，回想一下自己平时定目标时候那个标准通常都要飞上天去的习惯，今年堪称完美的实现了自己的目标。&lt;/p&gt;

&lt;p&gt;头三个月完成了生活环境的变化，并且把作息时间正常化。&lt;/p&gt;

&lt;p&gt;然后开始健身，主要是做平板撑之类的动作对自己进行腰部疼痛干预，坚持每天游泳锻炼心肺功能。9月开始游泳池脏到站不稳，游泳就停了，再之后泳池没了。附近倒是还有一个更大更好的泳池，但是手头钱太紧张就放弃了。从结果来说，比以前的自己总算是强壮了一丢丢，上臂看起来总算是正常的了，竟然还有了一点胸肌，以至于夏天我凸点了自己根本没注意，然后就被嘲笑了。&lt;/p&gt;

&lt;p&gt;养狗这事儿也越来越熟练，从最开始洗一次狗可能要折腾完一下午，到现在轻车熟路全套最多两小时搞定。不得不说的是，狗对于逃避洗澡这事儿也变得越来越机智，已经达到我才开始放音乐它就晓得要洗澡的地步。&lt;/p&gt;

&lt;p&gt;戒烟进展最好的时候是3月～7月，之后又开始反弹，目前维持在半包～一包/天的频率，还需努力。&lt;/p&gt;

&lt;p&gt;今年还看了不少书，所以明年的计划之一就是写一个读书笔记的系列来分享读书的乐趣，推广读书这事儿上佛系的我决定开启一个新的篇章，这篇博客大概也会改成另外一个更加中二的名字。&lt;/p&gt;

&lt;p&gt;另外今年没有因为穷就放弃现实中的社交，还是强行挤出来钱去保持稳定的社交活动了，认识了好多新朋友，增长了不少见识。比起现在网上糟糕（比如某乎，某博，网友很暴躁啊）的交流环境，现实中大家坐下来面对面交流其实非常有意思，之后应该会以故事的方式记录下来，标题已经想好了，但是怎么写还没想好。&lt;/p&gt;

&lt;p&gt;计划外的事情做了两件，目前来看是非常正确的决定。一是长期稳定的进行心理咨询，二是考研。&lt;/p&gt;

&lt;p&gt;考研的总结已经写了，发在了我专门用来记录&lt;a href=&quot;https://ms.lament-z.com&quot;&gt;考研的blog&lt;/a&gt;下面，当然心理咨询这事儿不太好写，等我把思路理顺了可能会写一点出来。&lt;/p&gt;

&lt;p&gt;总的来说今年虽然也有好几个月比较辛苦的在学习，但是从身体到精神的休整基本上完成了，2020年继续启程～&lt;/p&gt;

&lt;p&gt;好了流水账写完了，出门跟朋友们跨年咯～&lt;/p&gt;</content><author><name></name></author><category term="Scroll" /><summary type="html">小野不是妹纸的2019的反思</summary></entry></feed>