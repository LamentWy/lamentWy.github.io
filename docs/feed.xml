<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-07-14T10:45:29+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Lament’s Mage Tower</title><subtitle>Neutral, sometimes chaotic neutral</subtitle><entry><title type="html">Java集合类系列:Queue</title><link href="http://localhost:4000/collections-Queue" rel="alternate" type="text/html" title="Java集合类系列:Queue" /><published>2021-02-01T00:00:00+08:00</published><updated>2021-02-01T00:00:00+08:00</updated><id>http://localhost:4000/collections-Queue</id><content type="html" xml:base="http://localhost:4000/collections-Queue">&lt;h1 id=&quot;queue-笔记&quot;&gt;Queue 笔记&lt;/h1&gt;

&lt;h2 id=&quot;几种不同场景下的队列&quot;&gt;几种不同场景下的队列&lt;/h2&gt;

&lt;p&gt;数据结构中，通常把 FIFO 这种叫做队列，而 FILO 这种叫做栈。&lt;/p&gt;

&lt;p&gt;但是编码的时候队列和栈的实现都可以“看作”是不同性质的队列。&lt;/p&gt;

&lt;h2 id=&quot;queue-in-java&quot;&gt;Queue In Java&lt;/h2&gt;

&lt;p&gt;Queue 在Java中是作为接口出现的，它的文档也提现了这一点。&lt;/p&gt;

&lt;p&gt;FIFO就不是强制性的了。 这个接口定义了 新增/删除/检测三类操作，并且规定了两套实现规则：抛异常/返回特定值,见下表。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Summary of Queue methods&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ops&lt;/td&gt;
      &lt;td&gt;Throws exception&lt;/td&gt;
      &lt;td&gt;Returns special value&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Insert&lt;/td&gt;
      &lt;td&gt;add(e)&lt;/td&gt;
      &lt;td&gt;offer(e)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;remove&lt;/td&gt;
      &lt;td&gt;remove()&lt;/td&gt;
      &lt;td&gt;poll()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Examine&lt;/td&gt;
      &lt;td&gt;element()&lt;/td&gt;
      &lt;td&gt;peek()&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;deque&quot;&gt;Deque&lt;/h3&gt;

&lt;p&gt;Deque is short for “double ended queue”.&lt;/p&gt;

&lt;p&gt;它继承Queue接口，并在这个基础上做了双端队列的扩展，自然规定了双端队列的一整套方法。
同时它可以用作传统的FIFO “队列” ，也可以用作 “FILO” “栈”。 Java为这两种”场景”都提供了对应的方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;作为双端队列时，提供了12个方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Summary of Deque methods&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;ops&lt;/th&gt;
      &lt;th&gt;Head&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Tail&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Throws exception&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Special value&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Throws exception&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;Special value&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Insert&lt;/td&gt;
      &lt;td&gt;addFrist(e)&lt;/td&gt;
      &lt;td&gt;offerFirst(e)&lt;/td&gt;
      &lt;td&gt;addLast(e)&lt;/td&gt;
      &lt;td&gt;offerLast(e)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Remove&lt;/td&gt;
      &lt;td&gt;removeFirst()&lt;/td&gt;
      &lt;td&gt;pollFirst()&lt;/td&gt;
      &lt;td&gt;removeLast()&lt;/td&gt;
      &lt;td&gt;pollLast()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Examine&lt;/td&gt;
      &lt;td&gt;getFirst()&lt;/td&gt;
      &lt;td&gt;peekFirst()&lt;/td&gt;
      &lt;td&gt;getLast()&lt;/td&gt;
      &lt;td&gt;peekLast()&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;作为 FIFO Queue 时，提供如下方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Comparison of Queue and Deque methods&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Queue Method&lt;/th&gt;
      &lt;th&gt;Equivalent Deque Method&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;add(e)&lt;/td&gt;
      &lt;td&gt;addLast(e)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;offer(e)&lt;/td&gt;
      &lt;td&gt;offerLast(e)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;remove()&lt;/td&gt;
      &lt;td&gt;removeFirst()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;poll()&lt;/td&gt;
      &lt;td&gt;pollFirst()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;element()&lt;/td&gt;
      &lt;td&gt;getFirst()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;peek()&lt;/td&gt;
      &lt;td&gt;peekFirst()&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;作为 FILO Stack时，提供如下方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Comparison of Stack and Deque methods&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Stack Method&lt;/th&gt;
      &lt;th&gt;Equivalent Deque Method&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;push(e)&lt;/td&gt;
      &lt;td&gt;addFirst(e)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pop()&lt;/td&gt;
      &lt;td&gt;removeFirst()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;peek()&lt;/td&gt;
      &lt;td&gt;peekFirst()&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;arraydeque&quot;&gt;ArrayDeque&lt;/h3&gt;

&lt;p&gt;ArrayDeque 是基于变长数组对 Deque 的实现。&lt;/p&gt;

&lt;h4 id=&quot;性质&quot;&gt;性质&lt;/h4&gt;
&lt;p&gt;可自动扩容，具备双端队列的能力，非线程安全，具备快速失败的能力。&lt;/p&gt;

&lt;h4 id=&quot;源码分析&quot;&gt;源码分析&lt;/h4&gt;

&lt;h5 id=&quot;基于数组&quot;&gt;基于数组&lt;/h5&gt;

&lt;p&gt;就是个 Object 数组。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  transient Object[] elements; // non-private to simplify nested class access
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不过由于这个场景是双端队列，所以要看作是循环数组，在普通数组的基础上添加了头尾的标记，数组的头尾不再是array[0] 和 array[size-1]，而是由 head / tail 来决定，其中tail永远指向数组中的一个未被占用的元素。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  transient int head;

  transient int tail;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;安全性非线程安全&quot;&gt;安全性：非线程安全&lt;/h5&gt;

&lt;p&gt;快速失败，根据索引删除方法&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete(int index)&lt;/code&gt;和遍历元素的代码中都可以看到。&lt;/p&gt;

&lt;h5 id=&quot;遍历&quot;&gt;遍历&lt;/h5&gt;

&lt;p&gt;俩迭代器实现，一个从head遍历到tail，一个从tail到head。&lt;/p&gt;

&lt;h5 id=&quot;构造方法3个-无论使用哪个构造方法其容量一定是2的幂&quot;&gt;构造方法：3个 无论使用哪个构造方法，其容量一定是2的幂。&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;无参，默认数组容量为16
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ArrayDeque() {
    elements = new Object[16];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;指定数组容量 ,但数组真实容量永远是正好比 numElements 大的2的n次幂
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ArrayDeque(int numElements) {
    allocateElements(numElements);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;其中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allocateElements(numElements);&lt;/code&gt;的逻辑很简单就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new Object[calculateSize(numElements)]&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;主要看一下计算数组容量，如何让数组的真实容量永远是正好比 numElements 大的2的n次幂&lt;/p&gt;

    &lt;p&gt;当传入数组容量的参数不是2的幂时&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; private static int calculateSize(int numElements) {
        int initialCapacity = MIN_INITIAL_CAPACITY; //这个值为 8

        // Find the best power of two to hold elements.
        // Tests &quot;&amp;lt;=&quot; because arrays aren&apos;t kept full.
        if (numElements &amp;gt;= initialCapacity) { //如果我们指定的值大于8
           initialCapacity = numElements;
           initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  1);
           initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  2);
           initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  4);
           initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  8);
           initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt; 16);
           initialCapacity++;

       if (initialCapacity &amp;lt; 0)   // Too many elements, must back off
           initialCapacity &amp;gt;&amp;gt;&amp;gt;= 1;// Good luck allocating 2 ^ 30 elements
            }
            return initialCapacity;
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;以上代码的逻辑是：&lt;/p&gt;

    &lt;p&gt;如果我们给定的数组容量小于8，则按8创建。
如果比8大，则找到 正好大于给定值的2^n幂。
如果这个值大到INT越界，那它就是个负数，»&amp;gt;=1 可以把它变成一个至少 2 ^ 30 级别的整数&lt;/p&gt;

    &lt;p&gt;这里分析下计算容量的代码：&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  1);
initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  2);
initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  4);
initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  8);
initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt; 16);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;5行代码都非常相似，它的功能是找到比 numElements 大的那个 2^n .&lt;/p&gt;

    &lt;p&gt;原理如下：
首先，所有 2^n 的值，转化成二进制之后，肯定长这样： 1000000…0000。
然后减去1 ，变成 01111111….1111这样，高位的0忽略，就是 11111111…11111。&lt;/p&gt;

    &lt;p&gt;那怎么把 任意一个整数变成 1111…1111这样呢，就是代码里的办法了。&lt;/p&gt;

    &lt;p&gt;任意整数的二进制表示，忽略掉高位的0之后，他左边的第一位肯定是1，也就是长这样：
1xxxxxxx。
当它向右移动一位并补0之后，就变成01xxxxx&lt;/p&gt;

    &lt;p&gt;1xxxxxxx
01xxxxxx
–或运算–
11xxxxxx&lt;/p&gt;

    &lt;p&gt;这个时候，initialCapacity = 11xxxxxx 了&lt;/p&gt;

    &lt;p&gt;后面无论移动多少位都是这个原理，因为或操作代表只要不同时为0，都是1，而»&amp;gt;是一个右移补0的操作，意味着高位永远是1。
一共最多移动 1 + 2 + 4 + 8 + 16 = 31位，
如果这个数字非常大，也就是当31位移动完之后，才填满所有的1，一个填满了31位 111…111，再加1妥妥的越界啦。&lt;/p&gt;

    &lt;p&gt;同时这个操作还有个好处是，当你得到想要的结果后，后面的重复计算不会改变结果。&lt;/p&gt;

    &lt;p&gt;假设&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;numElements=9&lt;/code&gt;:&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;第一次运行
1001  aka initialCapacity = 9
0100  aka initialCapacity &amp;gt;&amp;gt;&amp;gt; 1
-或运算-
1100

第二次运行
1100
0011 aka initialCapacity &amp;gt;&amp;gt;&amp;gt;  2
----
1111 到这里其实已经拿到结果了

第三次运行
1111
0000 aka initialCapacity  &amp;gt;&amp;gt;&amp;gt;  4
----
1111

后两次略
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;同时这个过程可以看出来为什么 移动的位数 是 1 2 4 …这个序列。
移动第一次之后，头两位肯定是11xxxx，所以第二次直接右移动2补俩0，下一次自然就是1111xxx，以此类推。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把集合类的实例转化成对应的Deque的实例&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ArrayDeque(Collection&amp;lt;? extends E&amp;gt; c) {
    allocateElements(c.size());
    addAll(c);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h5 id=&quot;arraydeque-中操作元素的几个主要方法&quot;&gt;ArrayDeque 中操作元素的几个主要方法&lt;/h5&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ArrayDeque 是 Deque 的实现类，而前面介绍 Deque 时罗列的那么多方法它都得实现，打开源码能看到一万个方法，但是实际上主要的新增和删除元素的方法就四个：addFirst，addLast，pollFirst，pollLast。它源码里有三行单行注释说的就是这个。&lt;/p&gt;

&lt;p&gt;其他方法是根据这些定义的，基本不用看。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;addFirst()&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public void addFirst(E e) {
            if (e == null)
       throw new NullPointerException();
            elements[head = (head - 1) &amp;amp; (elements.length - 1)] = e; //主要看这句
            if (head == tail) //数组已满需要扩容
            doubleCapacity(); //这个后面展开
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;重点说addFirst，这个看明白了剩下3个都不难，而且这个跟自动扩容也有点关系。&lt;/p&gt;

&lt;p&gt;这个方法的作用是在 head 之前插入一个元素，并且把这个元素作为新的 head。&lt;/p&gt;

&lt;p&gt;完成这个操作需要考虑容量溢出和下标越界两种情况：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;容量溢出&lt;br /&gt;
    在 addFirst() 方法中一定不会出现容量溢出，因为在 ArrayDeque 的实现中，tail 永远指向一个可插入数据的空数组元素，所以 head最少也可以占用这个空，此时也正好满足插入完成后，head == tail 从而触发扩容。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数组下标越界&lt;br /&gt;
    下标越界是指，由于是双端链表，头尾位置不固定，对于这个方法而言就是发生在 head = 0 时，此时 head = head -1 ,也就是 -1。&lt;/p&gt;

    &lt;p&gt;下面来详细分析下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head = (head - 1) &amp;amp; (elements.length - 1)&lt;/code&gt;这段代码 ,它即完成了计算head新值的功能，又解决了-1越界的问题。&lt;/p&gt;

    &lt;p&gt;先从功能上分析，addFirst 时，head 的新值只需要考虑两种可能，head 是否为0，我们自己写代码时可能就会写出如下逻辑：&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; //伪代码
 if (head == 0){
   head = length -1;
 }else{
   head = head -1;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;而源码中则利用”与”运算的几个小技巧（tips的验证和推导在最后）：&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Tips1: n为任意整数，-1 &amp;amp; n 等价于 求n的补码，我们用的都是补码，说白了就是n， -1 &amp;amp; n === n&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Tips2: 任意正整数 m,n ,当 m &amp;lt;= 2^n-1时, m &amp;amp; (2^n - 1) ==  m mod (2^n -1) 文字描述： m 对 2^n - 1 进行与操作，等价于 m 对 2^n - 1 取模。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;这俩技巧有啥用呢，我们回到前面 head 求值那行代码。&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; head = (head - 1) &amp;amp; (elements.length - 1);

 //当head = 0时，容量甭管是多少，反正肯定是2^n ,上面的代码实际上变成了
 head = （-1 &amp;amp; elements.length - 1） = elements.length - 1 // 运用了tips1

 //当head != 0 时，head的取值范围是 1 ～ (length -1) ，head - 1 的范围就是 0 ~ (length -1 -1 )。
 // 也就是说 head - 1 &amp;lt; length - 1 恒成立 。
 // 俩正整数 n&amp;lt;m 时，n mod m 恒等于 n ，这里如果一下想不明白的话，可以套用数学里面的求余。
 head = (head -1) &amp;amp; (elements.length - 1) = head -1 ; //tips2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;源码用一行代码替换了我们前面写的if/else逻辑，并且提供了一些性能上的优势。&lt;/p&gt;

    &lt;p&gt;这也是为什么数组的实际容量 (elements.length) 一定是2的幂次，这是因为可以方便这里的取模(mod)操作，注意 mod (取模) 跟 % (取余) 对于计算机而言是有区别的，主要是返回结果的取舍上，比如 4 &amp;amp; 3 == 0 ，4 % 3 == 1。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;addLast()&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public void addLast(E e) {
      if (e == null)
        throw new NullPointerException();
        elements[tail] = e;
      if ( (tail = (tail + 1) &amp;amp; (elements.length - 1)) == head)
        doubleCapacity();
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个方法的作用是在 Tail 处直接添加新元素，然后 Tail 指向下一个空的数组元素，如果没有空的就进行扩容。与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addFirst()&lt;/code&gt;基本类似，区别在于要保证 Tail 永远要指向一个空的数组元素。&lt;/p&gt;

&lt;p&gt;还是老样子，根据这个需求我们先自己尝试实现一下。尾部同样是容量溢出和数组下标越界两个问题需要解决。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //伪代码  
    elements[tail] = newElement; //这一步是一定能完成的
    //判断数组此时是否已满，如果满了则扩容，如果没满，则tail +1

  if(isFull()){
    grow(); //扩容
    tail= tail + 1;
  }else{
    tail = tail + 1;
  }
  //由于是双端队列，判断数组是不是满了分为两种情况
  // head &amp;gt; tail 时，tail + 1 =head 则满了
  // head &amp;lt; tail 时，head + tail + 1 = length 就满了

  isFull(){
      if(head &amp;gt; tail){
        return tail +1 == head;
      }else{
        return head + tail + 1 == length;
      }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面的伪代码只解决了容量溢出的问题，没有解决数组下标越界的问题。&lt;/p&gt;

&lt;p&gt;比如情况1： head=4 ，tail=6，length=7，按照双端队列 tail 之后应该为 0，而不是 7；&lt;/p&gt;

&lt;p&gt;或者情况2： 如果head是1，tail是0，触发扩容，扩容之后，tail+1指到head头上去了。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //伪代码 moveTail只能解决情况1.
    moveTail(){
      if (tail + 1 == length){
        tail = 0;
      }else{
        tail = tail + 1;
      }
    }

    //为了解决情况2，我们需要在扩容时把双端数组规整一下。让head在新数组中回到0的位置去，其他的按照顺序依次填充。
    grow(){
      newArrary[length*2];
      //遍历旧数组，把head放到newArray[0]，其他的按顺序排列。
      head = 0;
      tail = length -1; //因为我们的伪代码里 grow()之后tail 还要+1
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;是不是特别麻烦，下面来看源码里为什么这么短。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  elements[tail] = e; //向空的数组元素中插入数据
  if ( (tail = (tail + 1) &amp;amp; (elements.length - 1)) == head) //即完成了tail的赋值工作，又完成了数组是否已满的判断。
    doubleCapacity();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于 tail 永远指向一个可插入数据的空数组元素，所以插入数据这一步&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;elements[tail] = e;&lt;/code&gt;是一定会完成的，如果满了就进行扩容，除非扩容失败，比如数组的容量超过数组允许的最大值会&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;throw new IllegalStateException(&quot;Sorry, deque too big&quot;);&lt;/code&gt;。扩容解决了，但是 tail 如何指向空的数组元素，这个在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;doubleCapacity();&lt;/code&gt;中进行保证，逻辑大体跟我们伪代码里一样，只不过它的tail = length，细节在扩容部分再说。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //拆分代码
    tail = (tail + 1) &amp;amp; (elements.length - 1);

    if(tail == head){
      doubleCapacity();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;根据前面 addFirst()中学到的技巧，当 (tail + 1) &amp;lt;= (elements.length - 1) 时，tail = tail + 1。但是 tail = length-1 时， 很明显 tail + 1 就是 length , 这时候代码转化为 tail = length &amp;amp; （length -1）= 0, 由于length一定是2^n所以，tail一定为0(这里不明白拉到最后看一眼tips3)。&lt;/p&gt;

&lt;p&gt;由于先计算了tail的新值，所以判断数组是否满了也不需要我们之前伪代码演示的那么麻烦了，直接判断 head == tail即可，并且也不存在tail 指向head这种情况发生，因为扩容之后head会重新回到0，tail则为length。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;pollFirst()&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public E pollFirst() {
        int h = head;
        @SuppressWarnings(&quot;unchecked&quot;)
        E result = (E) elements[h];
        // Element is null if deque empty
        if (result == null)
            return null;
        elements[h] = null;     // Must null out slot
        head = (h + 1) &amp;amp; (elements.length - 1);
        return result;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这方法就简单多了，把 elements[head] 取出来，然后把这个数组元素置为空，移动head。需要注意的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;elements[h] = null;     // Must null out slot&lt;/code&gt; 注释也说了，必须null掉。虽然好像不null掉也问题不大，判断扩容啥的都是根据下标来的，实际上问题很大，比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contains(Object o)&lt;/code&gt;方法就会出现poll完了，怎么还在的情况。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;pollLast
    同上，略。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;自动扩容&quot;&gt;自动扩容&lt;/h5&gt;
&lt;p&gt;当队列满了，或者说数组填充满元素时会触发自动扩容。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;触发扩容的条件&lt;/p&gt;

    &lt;p&gt;只有添加元素时才会触发自动扩容，也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addFirst()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addLast()&lt;/code&gt; 这俩方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自动扩容：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; private void doubleCapacity() {
        assert head == tail;
        int p = head;
        int n = elements.length;
        int r = n - p; // number of elements to the right of p
        int newCapacity = n &amp;lt;&amp;lt; 1;
        if (newCapacity &amp;lt; 0)
            throw new IllegalStateException(&quot;Sorry, deque too big&quot;);
        Object[] a = new Object[newCapacity];
        System.arraycopy(elements, p, a, 0, r);
        System.arraycopy(elements, 0, a, r, p);
        elements = a;
        head = 0;
        tail = n;
 }        
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;大体逻辑跟我们在伪代码中写的一样。
 通过 doubleCapacity() ，直接将原数组扩为2倍大小， int newCapacity = n « 1;
 如果这个值超过了数组允许的最大值，则throw new IllegalStateException(“Sorry, deque too big”);
 当扩容成功之后，对数组进行复制，由于循环数组是有头尾的，而且头尾会移动，
 所以复制的时候会在新数组中重新拼接一下之前的数组。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; //原数组中从 head 开始，向右到数组最后一个元素，顶头放入新数组
 System.arraycopy(elements, p, a, 0, r);
 //原数组中从 tail 开始, 向左的全部元素（换个方向描述就是从element[0] 到 tail 的全部元素)，拼接到a剩下的空槽中
 System.arraycopy(elements, 0, a, r, p);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tips&quot;&gt;tips&lt;/h2&gt;

&lt;h3 id=&quot;位运算符-和-正反补&quot;&gt;位运算符 和 正反补&lt;/h3&gt;

&lt;p&gt;表格的样式有点问题，讲究看吧，我前端是渣渣搞不清楚这个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;位运算符&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;ops&lt;/th&gt;
      &lt;th&gt;中文名&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;口诀 / 小技巧&lt;/th&gt;
      &lt;th&gt;例子&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;amp;&lt;/td&gt;
      &lt;td&gt;与&lt;/td&gt;
      &lt;td&gt;如果相对应位都是1，则结果为1，否则为0&lt;/td&gt;
      &lt;td&gt;同1为1，不同为0&lt;/td&gt;
      &lt;td&gt;A &amp;amp; B&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;或&lt;/td&gt;
      &lt;td&gt;或&lt;/td&gt;
      &lt;td&gt;如果相对应位都是 0，则结果为 0，否则为 1&lt;/td&gt;
      &lt;td&gt;同0为0，不同为1&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;^&lt;/td&gt;
      &lt;td&gt;异或&lt;/td&gt;
      &lt;td&gt;如果相对应位值相同，则结果为0，否则为1&lt;/td&gt;
      &lt;td&gt;相同为0，不同为1&lt;/td&gt;
      &lt;td&gt;A ^ B&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;～&lt;/td&gt;
      &lt;td&gt;取反&lt;/td&gt;
      &lt;td&gt;也叫按位取反，就是把每一位的数反转，即0变成1，1变成0&lt;/td&gt;
      &lt;td&gt;取反不需要口诀吧&lt;/td&gt;
      &lt;td&gt;~A&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;«&lt;/td&gt;
      &lt;td&gt;左移&lt;/td&gt;
      &lt;td&gt;把符号左面的数的二进制版本向左移动n位&lt;/td&gt;
      &lt;td&gt;1 « n = 2^n&lt;/td&gt;
      &lt;td&gt;假设A = 1, A « 2 = 4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;»&lt;/td&gt;
      &lt;td&gt;右移&lt;/td&gt;
      &lt;td&gt;跟左移一样，不过方向向右&lt;/td&gt;
      &lt;td&gt;n/a&lt;/td&gt;
      &lt;td&gt;假设A = 1, A » 2 = 0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;»&amp;gt;&lt;/td&gt;
      &lt;td&gt;按位右移补0&lt;/td&gt;
      &lt;td&gt;跟右移差不多，不过空位要补0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;正反补码&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;正负0&lt;/th&gt;
      &lt;th&gt;拓展&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;原码&lt;/td&gt;
      &lt;td&gt;原码最高位为符号为，0正1负，其余位置表示数值，不足位时在符号为和数值之间补0&lt;/td&gt;
      &lt;td&gt;正数的原码就是它本身，符号位为0；负数的原码符号位是1，其他跟正数一样；0就全是0&lt;/td&gt;
      &lt;td&gt;大致长这样：{1: 0 0001} {-1: 1 0001} {0: 0 0000} 但是不能做加减法，-1+1原码的结果是-2，于是搞了反码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;反码&lt;/td&gt;
      &lt;td&gt;反码主要折腾负数，负数的反码符号位依然为1，但是其他位要全部取反。&lt;/td&gt;
      &lt;td&gt;正数还是跟原码一样，负数前面说了，0就尴尬了，有俩0.&lt;/td&gt;
      &lt;td&gt;反码解决了 1-1 = -2的问题，但是根据符号位不同，诞生了正0和负0两个0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;补码&lt;/td&gt;
      &lt;td&gt;补码也是折腾负数，负数的补码是在其反码的末位+1，如果超出最高位则丢弃最高位&lt;/td&gt;
      &lt;td&gt;正数正反补码都一样，负数就是前面说的反码末位+1，0就是0啦&lt;/td&gt;
      &lt;td&gt;补码解决了双0问题，反码中负0全是1，末位+1之后最高位越界丢弃，只剩0，终于只有一个0了。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;补码，中补的来源，two’s complement，对2求补，这是离散数学中的一种计算方法，我念书的时候为啥离散数学没教这个。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;tips1&quot;&gt;tips1&lt;/h3&gt;

&lt;p&gt;-1 &amp;amp; n === 求n的补码 aka -1 &amp;amp; n === n，n 可以是任意整数。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;推导过程:
-1 ，其符号位为1，原码为 1 0001，但是计算机存储负数是存其补码，也就是符号位不变，其他位反转，之后末位+1
-1的反码: 1 1110 ,  
-1的补码: 1 1111 。

然后按位与操作的原则是： 同1则1，不同为0.

很明显-1这个所有位上全是1的二进制数 跟 任何整数 进行 与操作 都不会改变对方的值。

1111     1111
1010     0000
--------------
1010     0000

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;tips2&quot;&gt;tips2&lt;/h3&gt;

&lt;p&gt;任意正整数 m,n ，当 m &amp;lt;= 2^n-1时， m &amp;amp; (2^n - 1) ==  m mod (2^n -1)&lt;/p&gt;

&lt;p&gt;描述： m 对 2^n - 1 进行与操作，等价于 m 对 2^n - 1 取模。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 2^n 的二进制除了高位有个1，低位全是0，也就是 1000...000 这个样子。
 2^n -1 的二进制低位全是1，也就是 000111..111 这种样子。

 类似上面-1的那一堆1是不是。
 当 m &amp;lt;= 2^n - 1 时候，那么一定是这个样子
 m    : 0000 1001
 2^n-1: 0111 1111
 -----------------
 肯定还是m本身，跟前面-1的情况基本类似。  
 从取模的角度去思考的话，跟 2 mod 10 = 2 一样。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;tips3&quot;&gt;tips3&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2^n &amp;amp; 2^n-1 === 0
证明看下图:
2^n   : 1000...000
2^n-1 : 0111...111
----------按位与-----
        0000000000

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="Scroll" /><summary type="html">Queue 笔记</summary></entry><entry><title type="html">几种锁优化简介</title><link href="http://localhost:4000/lock-ad" rel="alternate" type="text/html" title="几种锁优化简介" /><published>2021-01-25T00:00:00+08:00</published><updated>2021-01-25T00:00:00+08:00</updated><id>http://localhost:4000/lock-ad</id><content type="html" xml:base="http://localhost:4000/lock-ad">&lt;h2 id=&quot;锁优化&quot;&gt;锁优化&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;高效并发是从JDK 5升级到JDK 6后一项重要的改进项，HotSpot虚拟机开发团队在这个版本上花 费了大量的资源去实现各种锁优化技术，如适应性自旋(Adaptive Spinning)、锁消除(Lock Elimination)、锁膨胀(Lock Coarsening)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以看到大部分优化都是针对&lt;strong&gt;阻塞同步&lt;/strong&gt;这个最重的操作进行的。&lt;/p&gt;

&lt;h3 id=&quot;自旋锁--适应性自旋锁&quot;&gt;自旋锁 &amp;amp; 适应性自旋锁&lt;/h3&gt;

&lt;p&gt;阻塞/互斥同步性能问题最大的原因是由于挂起和恢复线程很麻烦，并且很多共享数据的锁定时间很短，可能阻塞线程的挂起恢复还没完成，它锁定就结束了。&lt;/p&gt;

&lt;p&gt;针对这种情况，于是就出现了自旋锁，当一个线程持有共享数据时，另一个线程不必挂起，而是原地自旋spinning，这样不会进行挂起和恢复操作。&lt;/p&gt;

&lt;p&gt;当然缺点就是自旋时候依然占用着处理器时间，并且自旋操作没有意义，如果多次自旋后依然获取不到锁，还是要挂起。&lt;/p&gt;

&lt;p&gt;自旋次数默认为10次，并且可以通过JVM参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-XX: PreBlockSpin&lt;/code&gt;进行更改。&lt;/p&gt;

&lt;p&gt;而适应性自旋锁，就是自旋时间不固定（相对于前面的 单次自旋时间*自旋次数），它的时间取决于前一次在同一个锁上的自旋时间，以及锁的持有者的状态来决定。&lt;/p&gt;

&lt;p&gt;如果对于同一个共享资源（上锁的对象），一个线程自旋刚刚成功获取到锁，并且这个线程正在运行，那么JVM会认为该资源的其他等待线程接着自旋也很有可能很快获取到锁，于是JVM会允许这些等待线程进行更多的自旋次数；相反，如果某个共享资源，等待线程基本就没成功获取过锁，那么之后可能直接忽略掉自旋，转为直接挂起。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自旋 Spinning
所谓自旋Spinning，就是让线程自己保持状态原地自己玩一会儿。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;锁消除&quot;&gt;锁消除&lt;/h3&gt;

&lt;p&gt;锁消除是指JVM即时编译器运行时对同步代码进行检测，对于那些不可能存在竞争的共享数据上的锁进行消除。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可 以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于Java应用中除了开发者自行编写的代码外，Java类库、框架等等代码中是存在很多开发者并不知晓的同步代码的，只要逃逸分析发现代码中的共享资源的引用不会逃逸，并且其他线程永远访问不到他，这部分锁就会被即时编译器消除掉（解释执行时锁还是在的）。&lt;/p&gt;

&lt;h3 id=&quot;锁粗化&quot;&gt;锁粗化&lt;/h3&gt;

&lt;p&gt;原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据 的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。&lt;/p&gt;

&lt;p&gt;但是如果一系列的连续操作都对同一个对象反复加锁和 解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。&lt;/p&gt;

&lt;p&gt;这个时候JVM会把这一堆小锁换成一个包含这些资源的大锁，比如循环里的锁换成循环外的锁。&lt;/p&gt;

&lt;h3 id=&quot;轻量级锁&quot;&gt;轻量级锁&lt;/h3&gt;

&lt;p&gt;在代码即将进入同步块的时候，如果此同步对象没有被锁定(锁标志位为“01”状态)，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的Mark Word的拷贝(官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word)。&lt;/p&gt;

&lt;p&gt;然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位(Mark Word的 最后两个比特)将转变为“00”，表示此对象处于轻量级锁定状态。&lt;/p&gt;

&lt;p&gt;这时候线程堆栈里存着原来Mark Word的值，而Mark word的现在存的是指向Lock Record的指针。&lt;/p&gt;

&lt;p&gt;释放锁的过程也是通过CAS操作进行，指针如果还是指向线程的Lock Record，那么就把之前拷贝的Mark Word信息还给对象头。&lt;/p&gt;

&lt;p&gt;说完正常流程来说不正常流程。&lt;/p&gt;

&lt;p&gt;加锁过程中的CAS如果失败了，说明有其他线程竞争这个对象，JVM这个时候会先检测对象的Mark Word是不是指向（当前线程的栈中的）Lock Record的指针，如果是，那说明当前线程抢到这个锁了，执行同步块然后释放锁就好了；如果不是那说明这个对象被其他线程先抢走了，这个时候要么自旋一会儿，要么膨胀成重量级锁。&lt;/p&gt;

&lt;p&gt;释放锁过程中如果CAS操作失败，说明有其他线程尝试过获取锁，八成都膨胀成重量级锁了，这个时候要释放锁，并且唤醒其他挂起的线程。&lt;/p&gt;

&lt;h4 id=&quot;性能&quot;&gt;性能&lt;/h4&gt;

&lt;p&gt;轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销;但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对象头 Mark Word&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;&quot; alt=&quot;img TODO 对象头，线程的栈帧， 以及整个过程二者的交互图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;偏向锁&quot;&gt;偏向锁&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;(启用参数-XX:+UseBiased Locking，这是自JDK 6 起HotSpot虚拟机的默认值)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;偏向锁也是JDK 6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。&lt;/p&gt;

&lt;p&gt;偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。&lt;/p&gt;

&lt;p&gt;当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志 位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程 的ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作(例如加锁、解锁及对Mark Word的更新操作等)。&lt;/p&gt;

&lt;p&gt;一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是 否处于被锁定的状态决定是否撤销偏向(偏向模式设置为“ 0”)，撤销后标志位恢复到未锁定(标志位 为“ 01”)或轻量级锁定(标志位为“ 00”)的状态，后续的同步操作该膨胀膨胀，该解锁解锁。&lt;/p&gt;

&lt;p&gt;由于偏向锁没有保存对象头Mark word原本存着的信息（毕竟把CAS都省了），所以对象的hashcode是会丢失的。
Object::hashCode()或者System::identityHashCode(Object)这俩方法实际上返回值是对象的一致性哈希码(Identity Hash Code)，这个值就是存在MarkWord中的HashCode。很多API都是依赖这个值的，所以一但计算过这个哈希的对象，就永远不能进入偏向锁状态，处于该状态的对象如果收到计算这个哈希值的请求，就会立刻退出偏向锁状态，直接膨胀成重量级锁，而重量级锁和轻量级锁都是会保存Mark Word的。&lt;/p&gt;

&lt;h4 id=&quot;性能-1&quot;&gt;性能&lt;/h4&gt;

&lt;p&gt;同样是无竞争的情况越多效率越高。特殊情况下可能关闭之后效率更高。&lt;/p&gt;</content><author><name></name></author><category term="Scroll" /><summary type="html">锁优化</summary></entry><entry><title type="html">线程安全及常见的实现思路(draft)</title><link href="http://localhost:4000/Thread-Safe" rel="alternate" type="text/html" title="线程安全及常见的实现思路(draft)" /><published>2021-01-25T00:00:00+08:00</published><updated>2021-01-25T00:00:00+08:00</updated><id>http://localhost:4000/Thread-Safe</id><content type="html" xml:base="http://localhost:4000/Thread-Safe"># 线程安全

当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。

## 五种共享数据的类型

1. 不可变的类型  

  final关键字带来的可见性，保证了只要一个不可变对象（基本数据类型or不可变类的实例）正确的被创建了，那他就是线程安全的。

  当然对于不可变类，Java不能保证它的值不会变，这个要靠类自己的实现确保不会改变，比如String。

2. 绝对线程安全的类型  

  **“绝对线程安全”**类型的共享数据是指：无论在什么情况下，直接使用都不会出意外状况，由于要求过于严格，代价可能非常大。
  JavaAPI中很多线程安全的类都不是绝对线程安全，往往需要增加额外的同步手段，比如java.util.Vector。

3. 相对线程安全的类型
  此类共享数据是指：保证对该数据的单次操作是线程安全的，特殊情况需要调用方通过同步等手段保证正确。
  java.util.Vector 就是相对安全的类型。

4. 线程兼容的类型  
   这类共享数据，本身不是线程安全的，但是调用方可以使用同步手段，让这些数据在并发环境中正常工作。

5. 线程对立的类型  
   无论如何都不能被并发的数据。

## 线程安全的实现思路  

### 互斥同步/阻塞同步  

   互斥同步中，互斥指共享的数据本身是互斥的，同一时刻只能被一个线程（信号量则是一些）访问（主要是写/修改），以此保证多线程同时访问共享数据仍然保持同步。
   由于共享数据是互斥的，其他线程在锁释放前都会被阻塞，所以也叫阻塞同步。

   互斥同步/阻塞同步是一种悲观的并发策略，它假设不加锁就一定会出问题。

#### 互斥的实现方式

TODO

1. 临界区 Critical Section

2. 互斥量 Mutex

3. 信号量 Semaphore

#### 实现互斥同步的几种方式：

##### synchronized块

  先回忆下前面的知识：

  更大范围的原子性保证通过 lock 和 unlock 来实现，JVM提供了 monitorEnter 和 monitorExit 来隐式的使用 lock 和 unlock ，代码中对应的则是 synchronized 关键字。

  主流Java虚拟机实现中，Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免地陷入用户态到核心态的转换中，进行这种状态转换需要耗费很多的处理器时间。

  所以 synchronized 会被编译成 monitorEnter monitorExit 这两条字节码指令，这两个字节码指令都需要一个 reference 类型的参数来指明 要锁定和解锁的对象。如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference;如果没有明确指定，那将根据synchronized修饰的方法类型(如实例方法或类方法)，来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。

      1. synchronized块中的代码，可以被同一线程重复进入，简称可重入。

      2. 释放锁之前无条件阻塞其他线程。其他的线程拿他一点办法没有。

  根据上面的信息可以看出，synchronized块是一种重量级的操作，首先它会阻塞其他线程，这种阻塞会导致大量的状态转换。

##### 重入锁(ReentrantLock)

  由于synchronized块的局限性(只能对引用类型加锁，只能等执行结束or异常中断，不可避免的切换代价)，Java类库提供了java.util.concurrent包，通常被简称为JUC，其中java.util.concurrent.locks.Lock接口便成了Java的另一种全新的互斥同步手段。

  基于Lock接口，用户能够以非块结构(Non-Block Structured)来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面去实现同步。

  重入锁-ReentrantLock就是Lock的一种实现。 与synchronized块一样它是可重入的（就这种锁都带个计数器），但是多了一些高级功能：

  1. 等待可中断
    当持有锁的线程长时间不放弃锁的话，等待线程可以放弃等待，然后去干别的。
    synchronized block 的话，就只能老老实实的等着。

  2. 公平锁  
    所谓公平就是，一个锁释放后，其他等待线程按照先来后到的顺序获取锁。
    重入锁(ReentrantLock) 默认和synchronized块一样都是非公平锁，一个锁释放后，其他在等待的线程谁抢到是谁的。
    不过重入锁(ReentrantLock) 可以通过构造函数的参数来创建成公平的可重入锁。

  3. 锁可以绑定多个条件  
    一个ReentrantLock对象可以绑定多个Condition对象。
    synchronized块 锁对象的wait()和notify()/notifyAll()配合起来实现一个隐含条件，但是多个条件就得多加对应数量的锁。


### 非阻塞同步    

    这种一种乐观的并发策略，这种策略认为不对被共享的数据“加锁”，直接操作也不一定就会出错。
    所以它是先对数据操作，如果这期间共享数据确实没有被其他线程折腾，那就直接成功；如果发生了冲突，那再执行补救措施，比如重试等。

    这种策略中非常重要的两步 操作 和 冲突检测 这两步必须具备原子性，而且需要由硬件指令来保证（软件的话保证它们的原子性就又绕回阻塞同步了），当硬件指令可以保证这两部操作的原子性时，这种策略就成为了可能，Java中给开发者提供的是 CAS(Compare-and-Swap) 指令。

    比如Java类库里的原子整数类型的自增方法  AtomicInteger.incrementAndGet().
    虽然CAS很美好，但是存在ABA问题。
#### ABA问题

  假设 letter = &quot;A&quot;， T1 读到letter的值为A，然后T1做了一些准备工作，做完后又读取letter（还是A）打算给它赋值。这个A是T1第一次读到的A吗？

  T1做准备工作的时候，它不知道有没有一个T2来了，并且T2 把letter的值改为了B，然后又改回了A。

  为了解决ABA问题，它们又给letter加了个时间戳属性，但是比较鸡肋，因为大部分时候ABA问题不会导致并发错误。

### 无同步  

  这种策略就干脆是，我所有的代码都不存在变量被并发访问的情况，即便有一些共享数据但是我把他们都放在同一个线程里(Thread Local Storage)，自然也就无所谓线程安全。</content><author><name></name></author><category term="Scroll" /><summary type="html"># 线程安全</summary></entry><entry><title type="html">Java内存模型</title><link href="http://localhost:4000/JMM-And-Thread" rel="alternate" type="text/html" title="Java内存模型" /><published>2021-01-23T00:00:00+08:00</published><updated>2021-01-23T00:00:00+08:00</updated><id>http://localhost:4000/JMM-And-Thread</id><content type="html" xml:base="http://localhost:4000/JMM-And-Thread">&lt;h1 id=&quot;jvm内存模型与线程&quot;&gt;JVM内存模型与线程&lt;/h1&gt;

&lt;h2 id=&quot;java内存模型概述&quot;&gt;Java内存模型概述&lt;/h2&gt;

&lt;p&gt;屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。&lt;/p&gt;

&lt;p&gt;Java内存模型的主要目的是定义程序中各种变量的访问规则。&lt;/p&gt;

&lt;p&gt;主要关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。&lt;/p&gt;

&lt;p&gt;Java内存模型规定了所有的变量都存储在主内存(Main Memory)中。&lt;/p&gt;

&lt;p&gt;每个线程还有自己的工作内存(Working Memory)。&lt;/p&gt;

&lt;p&gt;线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的数据。&lt;/p&gt;

&lt;p&gt;不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。&lt;/p&gt;

&lt;h3 id=&quot;变量&quot;&gt;变量&lt;/h3&gt;
&lt;p&gt;这里的变量指的是实例字段、静态字段，数组的元素等等，但是不包括局部变量和方法参数（因为线程私有）。&lt;/p&gt;

&lt;h3 id=&quot;主内存-main-memory&quot;&gt;主内存 Main Memory&lt;/h3&gt;

&lt;p&gt;主内存(Main Memory)中存储所有的变量。&lt;/p&gt;

&lt;p&gt;类似硬件上的内存。&lt;/p&gt;

&lt;h3 id=&quot;工作内存-working-memory&quot;&gt;工作内存 Working Memory&lt;/h3&gt;

&lt;p&gt;保存了被该线程使用的变量的主内存副本。&lt;/p&gt;

&lt;p&gt;线程对变量的所有操作(读取、赋值等)都在此处进行，不允许直接读写主内存数据。&lt;/p&gt;

&lt;p&gt;类似硬件中的CPU高速缓存。&lt;/p&gt;

&lt;h3 id=&quot;线程-工作内存-主内存交互关系图&quot;&gt;线程-工作内存-主内存交互关系图&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;&quot; alt=&quot;TODO——交互关系图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;jmm与runtime-data-area&quot;&gt;JMM与Runtime Data Area&lt;/h3&gt;

&lt;p&gt;二者均为JVM在内存方面的抽象模型，但是相互之间可以看作没有关系（主要是两者关注的点不同）。&lt;/p&gt;

&lt;h2 id=&quot;jmm---内存交互&quot;&gt;JMM - 内存交互&lt;/h2&gt;

&lt;p&gt;关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种原子操作来完成。&lt;/p&gt;

&lt;h3 id=&quot;8个原子操作&quot;&gt;8个原子操作&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;lock(锁定):&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作用于主内存的变量，它把一个变量标识为一条线程独占的状态。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;unlock(解锁):&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;read(读取):&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;load(载入):&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;use(使用):&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值
的字节码指令时将会执行这个操作。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;assign(赋值):&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量。&lt;/p&gt;

&lt;p&gt;每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;store(存储):&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;write(写入):&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。&lt;/p&gt;

&lt;h4 id=&quot;使用规范&quot;&gt;使用规范&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;read -&amp;gt; load 必须按顺序出现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是，必须先把变量的值读到工作内存中，然后才能把这个值给到工作内存中的变量的副本。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;store -&amp;gt; write 必须按顺序出现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;必须先把工作内存中变量的值传输到主内存，然后主内存才能把这个值写入对应的变量。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;(read &amp;amp; load)&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;(store &amp;amp; write) 必须成对出现&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是说不允许读值不存、无值存储、回写主存不接受，无值回写…&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;assign 必须完成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不允许一个线程丢弃它最近的assign操作。&lt;/p&gt;

&lt;p&gt;即变量在工作内存中改变了之后必须把该变化同步回主内存。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不允许无因 store + write。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不允许一个线程无原因地(没有发生过任何assign操作)把数据从线程的工作内存同步回主内存中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新的变量只能在主内存中“诞生”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化(load or assign)的变量。&lt;/p&gt;

&lt;p&gt;换句话说就是对一个新变量实施use、store操作之前，必须先执行 assign 和 load 操作。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个变量同一时刻只能被一条线程Lock&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执 行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对变量进行Lock会清空工作内存中此变量的值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;未经Lock的变量不允许unlock，也不允许跨线程unLock&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Unlock前必须先同步回主内存中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store、write操作)。&lt;/p&gt;

&lt;h4 id=&quot;等价化简&quot;&gt;等价化简&lt;/h4&gt;

&lt;p&gt;Java内存模型的操作简化为read、write、lock和unlock四种，但这只是语言描述上的等价化简。&lt;/p&gt;

&lt;h4 id=&quot;volatile&quot;&gt;volatile&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;origin mean: (of a computer’s memory) retaining data only as long as there is a power supply connected.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当一个变量被定义成volatile之后，它将具备两项特性:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;第一个语义是保证此变量对所有线程的可见性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。&lt;/p&gt;

&lt;p&gt;普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再对主内存进行读取操作，新变量值才会对线程B可见。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;第二个语义是禁止指令重排序优化。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;会加入内存屏障（Memory Barrier or Memory Fence），该屏障保证指令重排时不会将屏障后面的指令重排序到屏障之前。&lt;/p&gt;

&lt;p&gt;普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在同一个线程的方法执行过程中无法感知到这点，这就是Java内存模型中描述的所谓“线程内表现为串行的语义”(Within-Thread As-If-Serial Semantics)。&lt;/p&gt;

&lt;h4 id=&quot;long和double的非原子性协定-non-atomic-treatment-of-double-and-long-variables&quot;&gt;long和double的非原子性协定 (Non-Atomic Treatment of double and long Variables)&lt;/h4&gt;

&lt;p&gt;在模型中对Long和double特别定义了一条宽松的规定:
允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否 要保证64位数据类型的 load、store、read和 write 这四个操作的原子性。&lt;/p&gt;

&lt;h4 id=&quot;原子性可见性与有序性&quot;&gt;原子性、可见性与有序性&lt;/h4&gt;

&lt;p&gt;并发需要关注的三个特征。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;原子性(Atomicity)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Java内存模型直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的，例外就是long和double的非原子性协定。&lt;/p&gt;

&lt;p&gt;更大范围的原子性保证通过 lock 和 unlock 来实现，JVM提供了 monitorEnter 和 monitorExit 来隐式的使用 lock 和 unlock ，代码中对应的则是 synchronized 关键字。&lt;/p&gt;

&lt;p&gt;也就是代码中通过 synchronized 块中的操作可以保证更大范围的原子性。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可见性(Visibility)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所谓可见性指的是：一个线程修改了共享变量的值时，其他线程能立刻知晓这个修改。&lt;/p&gt;

&lt;p&gt;volatile, synchronized, final均可提供可见效。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;volatile&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;它的可见性的提供方式是： 共享变量被修改后，会将新值同步回主内存；然后该变量每次被读取前，都会先从主内存刷新最新的值。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;synchronized&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;它的可见性的提供方式是： 前面说了 synchronized 可以看成是通过lock和unlock来保证原子性，其可见性则是在unlock之前，必须先将变量同步回主内存实现的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;final&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为它不可变，主要正确初始化了（没有发生this引用逃逸），就天然提供可见性。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;有序性(Ordering)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果在本线程内观察，所有的操作都是有序的;如果在一个线程中观察另一个线程，所有的操作都是无序的。
前半句是指“线程内似表现为串行的语义”(Within-Thread As-If-Serial Semantics) ，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象 。&lt;/p&gt;

&lt;p&gt;Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性。
volatile关键字本 身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。&lt;/p&gt;

&lt;p&gt;JMM的其他有序性则通过&lt;strong&gt;先行发生原则&lt;/strong&gt;提供。&lt;/p&gt;

&lt;h3 id=&quot;先行发生-happens-before-order&quot;&gt;先行发生 （Happens-before Order）&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;偏序 Partially ordered： 这也是个数学概念，是对一个集合中元素顺序or排序的直觉概念的抽象，说人话就是，偏序就是部分元素之间有序，不要求所有的元素互相之间都有顺序关系。&lt;br /&gt;
可以把偏序的组成看成两个部分，一个是元素集合本身，一个是匹配给这个元素集合的排序方式， 比如说自然数集合+从小到大排列（&amp;lt;=），这就是个偏序，只不过这个偏序全都满足条件，所以它还是全序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;先行发生是Java内存模型中定义的两项操作之间的&lt;strong&gt;&lt;em&gt;偏序关系&lt;/em&gt;&lt;/strong&gt;，下文把这种偏序简称为HB。&lt;/p&gt;

&lt;p&gt;所谓按照“先行发生”对原子操作进行排序 或者说 对于两个原子操作之间具备 前者 先行发生于 后者：&lt;/p&gt;

&lt;p&gt;如果操作A 先行发生 操作B，记作hb(A,B)，那么意味着，操作A必须排在操作B之前（这个排真正执行中的排，不是代码书写的前后顺序），并在操作A对操作B是可见的。&lt;/p&gt;

&lt;p&gt;（实在觉得别扭你可以参考这段解释： 自然数集合中任意俩元素A,B 满足 A &amp;lt; B ，则意味着A在B之前，并且A的值小于B的值 ）&lt;/p&gt;

&lt;p&gt;[Oracle-Happens-before Order][https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5]&lt;/p&gt;

&lt;p&gt;任意俩个原子操作A、B，如果满足hb(A,B),那么自然具备线程安全的特性，无需使用synchronized等手段。&lt;/p&gt;

&lt;p&gt;《深入》一书中在12.3.6中介绍的各种规则都是根据HB推导出来的。&lt;/p&gt;

&lt;p&gt;比如 管程锁定规则(Monitor Lock Rule)，对于同一个变量而言，你上了锁肯定之后得解锁，并且你解锁后另一个线程才能给它上锁，看起来似乎是hb(x,y)和hb(y,x)，实际上对先上锁后解锁 和 解锁后新加锁，这是两个不同的场景，依然是hb(x,y)。&lt;/p&gt;

&lt;p&gt;再比如 传递性(Transitivity): if hb(a,b) and hb(b,c) then hb(a,c) ，这个实际上就是偏序本身就具备的传递性，就像不等式的传递性。&lt;/p&gt;</content><author><name></name></author><category term="Scroll" /><summary type="html">JVM内存模型与线程</summary></entry><entry><title type="html">JVM-类加载笔记-草稿</title><link href="http://localhost:4000/classloading" rel="alternate" type="text/html" title="JVM-类加载笔记-草稿" /><published>2021-01-17T00:00:00+08:00</published><updated>2021-01-17T00:00:00+08:00</updated><id>http://localhost:4000/classloading</id><content type="html" xml:base="http://localhost:4000/classloading">&lt;h1 id=&quot;笔记&quot;&gt;笔记&lt;/h1&gt;

&lt;p&gt;Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。&lt;/p&gt;

&lt;h2 id=&quot;类加载的整个生命周期&quot;&gt;类加载的整个生命周期&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://lament-z.com/assets/images/JVM/class-life-circle.jpg&quot; alt=&quot;pic of class life circle&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中验证、准备、解析三个阶段统称为：连接 Linking。&lt;/p&gt;

&lt;p&gt;图中的整个生命周期中，解析可能在初始化之后才开始，并且很多阶段是交叉混合运行的，并不是某阶段结束后下一阶段才开始。&lt;/p&gt;

&lt;h3 id=&quot;加载-loading&quot;&gt;加载 Loading&lt;/h3&gt;

&lt;p&gt;加载阶段JVM要完成三件事：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过类的全限定名拿到这个类的二进制字节流。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把这个字节流转化成方法区的运行时数据结构。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内存中生成一个代表这个类的java.lang.Class对象，作为这个类在方法区的访问入口。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;说白了就是找到类，拿到它的数据，按照JVM的要求进行存储，然后在内存里打个招牌，就可以营业了。&lt;/p&gt;

&lt;p&gt;这一步就有很多方式:&lt;/p&gt;

&lt;p&gt;比如从jar,war中读取&lt;/p&gt;

&lt;p&gt;运行时计算生成（动态代理技术），java.lang.reflect.Proxy中的ProxyGenerator.generateProxyClass()。&lt;/p&gt;

&lt;p&gt;从其他文件中生成类，比如jsp。&lt;/p&gt;

&lt;p&gt;不常见和没见过的，从加密文件中获取，网络中获取，数据库中读取。&lt;/p&gt;

&lt;p&gt;加载阶段获取类的二进制字节流的这个动作，是实现代码动态性的一个重要口子。&lt;/p&gt;

&lt;p&gt;数组又不太一样。&lt;/p&gt;

&lt;p&gt;数组本身是jvm在内存中直接动态生成的，但是它的类型也跟类加载有关系。
首先它有俩类型，一个element type ,一个component type.&lt;/p&gt;

&lt;p&gt;component type 比较好理解，数组的特点就是它存储一堆相同类型的元素，在jvms里面 数组里这些元素就是component，他们的类型就是component type。&lt;/p&gt;

&lt;p&gt;这个element type就很绕了，但实际麻烦的是component type，先上原文。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The component type of an array may itself be an array type.
The components of such an array may contain references to subarrays.
If, starting from any array type, one considers its component type, and then (if that is also an array type) the component type of that type, and so on, eventually one must reach a component type that is not an array type; this is called the element type of the original array, and the components at this level of the data structure are called the elements of the original array.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这也是《深入》一书中所说的去掉所有维度的类型。&lt;/p&gt;

&lt;p&gt;就是数组中的元素可以是数组，而且这个嵌套可以一直往下套，一直套到最后这个数组它的元素不是数组为止，这个不是数组的元素的类型就叫元素类型。说白了就是数组套娃套完之后的类型。数组的元素类型最终依然需要类加载器来加载。&lt;/p&gt;

&lt;p&gt;而数组的组件类型如果是引用类型的话，就要通过递归的方式加载组件类型，然后标识在对应的类加载器的 类命名空间上。
不是引用类型，则是把标识与引导类加载器关联。&lt;/p&gt;

&lt;p&gt;加载阶段开始进行之后，就会有linking中的动作要开始执行了，比如校验：检查字节码文件的格式等。&lt;/p&gt;

&lt;p&gt;但是开始的顺序肯定是 加载先开始，然后校验再开始。&lt;/p&gt;

&lt;h3 id=&quot;linking---1-校验-verification&quot;&gt;Linking - 1 校验 Verification&lt;/h3&gt;

&lt;p&gt;说加载的时候说了一万次二进制字节流，通过对加载阶段的了解，我们可以知道在字节码这个环节我们多少还是可以皮一下的。
所以JVM一定会对这些个二进制字节流进行校验。&lt;/p&gt;

&lt;p&gt;瞄了一眼jvms 校验这块真的好长啊，大致可以分为以下四类校验。&lt;/p&gt;

&lt;p&gt;挑几个好玩的记录一下。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;文件格式校验&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。&lt;/p&gt;

&lt;p&gt;这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以后面的三个验证阶段 全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。&lt;/p&gt;

&lt;p&gt;比如：是否以魔数&lt;strong&gt;0xCAFEBABE&lt;/strong&gt;开头&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;元数据校验&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第二阶段是对字节码描述的信息进行语义分析。
有点像检查语法错误一样，主要是保证这些信息符合jls。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;字节码校验&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;简单的说就是“检查代码”。&lt;/p&gt;

&lt;p&gt;主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。
这阶段要对类的方法体(Class文件中的Code属性)进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。&lt;/p&gt;

&lt;p&gt;然后这事儿就很麻烦（“停机问题”(Halting Problem)），最终在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化，把尽可能多的校验辅助措施挪到Javac编译器里进行。&lt;/p&gt;

&lt;p&gt;具体做法是给方法体Code属性的属性表中新增加了一项名为“StackMapTable”的新属性，这项属性描述了方法体所有的基本块(Basic Block，指按照控制流拆分的代码块)开始时本地变量表和操作栈应有的状态。&lt;/p&gt;

&lt;p&gt;在字节码验证期间，Java虚拟机就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。&lt;/p&gt;

&lt;p&gt;将字节码验证的类型推导转变为类型检查，从而节省了大量校验时间。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;符号引用校验&lt;br /&gt;
这个校验发生在 JVM 将符号引用转化为直接引用的时候，而这个转化行为发生在解析阶段。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;linking---准备-preparation&quot;&gt;linking - 准备 Preparation&lt;/h3&gt;

&lt;p&gt;准备阶段是正式为类变量(the static fields for a class or interface)分配内存并设置类变量初始值的阶段.&lt;/p&gt;

&lt;p&gt;这些变量所使用的内存都应当在方法区中进行分配，但是方法区本身是个抽象概念，Java8之前是永久代实现方法区，所以分配在永久代（假设有），Java8开始用元空间替换永久代，以前永久代的一部分数据现在被安排去了Heap中，这里面就包括类变量。&lt;/p&gt;

&lt;p&gt;并且这里设置类变量的初始值的时候，设置的是这个变量所属类型的0值。
例如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public static int i = 123;&lt;/code&gt; 在这个阶段就是i=0，123这个值要等到类初始化阶段，类构造器&lt;clinet&gt;()方法里面，putstatic指令把123给到i.&lt;/clinet&gt;&lt;/p&gt;

&lt;p&gt;但是像&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Integer.MAX_VALUE&lt;/code&gt;这种则会直接赋值为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffff&lt;/code&gt;，因为它的定义是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public static final int   MAX_VALUE = 0x7fffffff;&lt;/code&gt; 多了个final，这个值不可变，那么在编译阶段，也就是javac干活的时候会给 MAX_VALUE 生成 ConstantValue 属性，等到准备阶段，JVM 会根据 ConstantValue 来初始化 MAX_VALUE 的值。&lt;/p&gt;

&lt;h3 id=&quot;解析-resolution&quot;&gt;解析 Resolution&lt;/h3&gt;

&lt;p&gt;解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程.&lt;/p&gt;

&lt;p&gt;符号引用(Symbolic References):&lt;/p&gt;

&lt;p&gt;符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。&lt;/p&gt;

&lt;p&gt;直接引用(Direct References):&lt;/p&gt;

&lt;p&gt;直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;TODO 需要重新思考这部分内容。&lt;/p&gt;

&lt;p&gt;直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实现上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。&lt;/p&gt;

&lt;p&gt;JVMS只规定了解析发生的时间需要在执行操作符号引用的字节码指令之前，具体是类加载时就解析还是要用的时候再解析要根据不同JVM自身实现来看。&lt;/p&gt;

&lt;p&gt;对同一个符号引用进行多次解析 和 一次解析之后缓存解析结果 这两种情况都是存在的。&lt;/p&gt;

&lt;p&gt;比如对于invokedynamic这种用于动态语言支持的指令，就肯定每次都要重新解析。&lt;/p&gt;

&lt;p&gt;解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7 类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、 CONSTANT_M ethodref_info、CONSTANT_InterfaceM ethodref_info、 CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info和
CONSTANT_InvokeDynamic_info 8种常量类型。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;初始化--initialization&quot;&gt;初始化  initialization&lt;/h3&gt;
&lt;p&gt;初始化阶段就是执行类构造器&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法的过程。&lt;/p&gt;

&lt;p&gt;除了通过自定义类加载器的方式局部参与之外，其他的动作全部由JVM控制。&lt;/p&gt;

&lt;h4 id=&quot;类构造器方法-clinit&quot;&gt;类构造器方法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;这个方法是编译阶段javac根据源代码自动生成的。&lt;/p&gt;

&lt;p&gt;·&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法是由编译器自动收集类中的所有&lt;strong&gt;类变量的赋值动作&lt;/strong&gt;和&lt;strong&gt;静态语句块&lt;/strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(static{})&lt;/code&gt;中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;TODO  考虑移除这个种阻塞的描述&lt;/p&gt;

&lt;p&gt;JVM必须保证一个类的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法，其他线程都需要阻塞等待，直到活动线程执行完毕&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法。如果在一个类的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。&lt;/p&gt;

&lt;p&gt;同一个类加载器下，一个类型就初始化一次，虽然其他线程会被阻塞，但是只要干活儿的那个线程退出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法之后，其他阻塞线程唤醒后不会再进入该方法。
___&lt;/p&gt;

&lt;h4 id=&quot;必须执行初始化的六种情况&quot;&gt;必须执行初始化的六种情况&lt;/h4&gt;

&lt;p&gt;TODO 很明显这六种必须初始化的情况都属于 类可能是第一次被使用的情况。 考虑移除。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;遇到这四种字节码指令时：new getstatic putstatic invokestatic。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果遇到这些字节码指令，但是类型还没有初始化时，要先初始化。&lt;/p&gt;

&lt;p&gt;对应的代码场景为：&lt;/p&gt;

&lt;p&gt;new 对象的时候。&lt;/p&gt;

&lt;p&gt;读取或设置一个类型的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外，如Integet.MAX_VALUE)
的时候。&lt;/p&gt;

&lt;p&gt;调用一个类型的静态方法的时候。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用java.lang.reflect包的方法对类型进行反射调用的时候&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果类型没有进行过初始化，则需要先触发其初始化。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先
初始化这个主类。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当使用JDK 7新加入的动态语言支持时。
如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当一个接口中定义了JDK 8新加入的默认方法(被default关键字修饰的接口方法)时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上场景中的行为统称为对一个类型进行&lt;strong&gt;主动引用&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;有主动肯定还有&lt;strong&gt;被动引用&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;类加载器&quot;&gt;类加载器&lt;/h2&gt;

&lt;p&gt;能实现 &lt;strong&gt;通过一个类的全限定名来获取描述该类的二进制字节流&lt;/strong&gt; 这个功能的代码，都叫类加载器。&lt;/p&gt;

&lt;h3 id=&quot;类和类加载器&quot;&gt;类和类加载器&lt;/h3&gt;

&lt;p&gt;对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。&lt;/p&gt;

&lt;p&gt;每一个类加载器，都拥有一个独立的类名称空间。&lt;/p&gt;

&lt;p&gt;两个类是否相等必须是处于同一个类加载器下面，否则哪怕是同一个class文件被同一个VM加载，只要加载器不同，这俩类就不一样，equals() isAssignableFrom(),isInstance()等都受到类加载器的影响。&lt;/p&gt;

&lt;p&gt;这个验证也很好验证，自己创建一个类A和一个类加载器CL，然后用CL加载一个A出来，去跟直接new的比。&lt;/p&gt;

&lt;h3 id=&quot;双亲委派-parents-delegation-model&quot;&gt;双亲委派 parents delegation model&lt;/h3&gt;
&lt;p&gt;翻译导致误解的又一个例子，歧义有点多，反正我第一次看到这个词以为是从双亲向下递归，结果它是反着来的。&lt;/p&gt;

&lt;p&gt;在JVM的视角，只存在两种不同的类加载器.&lt;/p&gt;

&lt;p&gt;启动类加载器（Bootstrap ClassLoader)，由C++实现（也有java写的关机方法通过JNI回调c），是JVM自身的一部分；&lt;/p&gt;

&lt;p&gt;另一种就是其他类加载器，独立于JVM之外，由java语言实现的，全部继承自抽象类java.lang.ClassLoader。&lt;/p&gt;

&lt;p&gt;Extension ClassLoader&lt;/p&gt;

&lt;p&gt;Application ClassLoader&lt;/p&gt;

&lt;p&gt;双亲委派模型的工作过程是:&lt;/p&gt;

&lt;p&gt;如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去完成加载。&lt;/p&gt;

&lt;p&gt;但它不是一个强制性约束。&lt;/p&gt;

&lt;h3 id=&quot;破坏双亲委派模型&quot;&gt;破坏双亲委派模型&lt;/h3&gt;

&lt;p&gt;Java发展的历史上出现过三次大规模破坏双亲委派模型的情况。
Java9之后顺便发生了第四次。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;第一次导致模型被破坏是双亲委派模型诞生之前。
java.lang.ClassLoader在Java第一个版本就存在了，搞出来好多自定义的classLoader，但是双亲委派模型从Jdk1.2开始引入，为了向前兼容，无法用技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个新的 protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass()中编写代码。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第二次被破坏是由于模型自身的短板&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;双亲委派很好地解决了各个类 加载器协作时基础类型的一致性问题(越基础的类由越上层的加载器进行加载)，基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在。&lt;/p&gt;

&lt;p&gt;但是还存在基础类型又要调用回用户的代码的情况。&lt;/p&gt;

&lt;p&gt;然后Java设计团队引入了一个可以逆向的加载器，线程上下文类加载器 (Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方 法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。&lt;/p&gt;

&lt;p&gt;有了这个加载器，就可以做出父类加载器去请求子类加载器完成类加载的行为。&lt;/p&gt;

&lt;p&gt;Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、 JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供 者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了 java.util.ServiceLoader类，以M ETA-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加 载提供了一种相对合理的解决方案。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;热部署&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OSGi模块化热部署。 核心就是自定义的类加载机制，每个bundle都有自己的类加载器，需要热替换的时候，连bunlde带它的类加载器一起替换。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;模块化&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;双亲委派模型基本还存在，但是发生了一丢丢变化，委派给父加载器之前要先判断下能不能归属到某个系统模块，如果可以就优先委派给负责该模块的加载器。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Run-time Built-in Class Loaders&lt;/strong&gt; &lt;br /&gt;
The Java run-time has the following built-in class loaders:&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;Bootstrap class loader&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt; It is the virtual machine’s built-in class loader, typically represented as null, and does not have a parent.&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;Platform class loader&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;All platform classes are visible to the platform class loader that can be used as the parent of a ClassLoader instance. Platform classes include Java SE platform APIs, their implementation classes and JDK-specific run-time classes that are defined by the platform class loader or its ancestors.&lt;br /&gt;
To allow for upgrading/overriding of modules defined to the platform class loader, and where upgraded modules read modules defined to class loaders other than the platform class loader and its ancestors, then the platform class loader may have to delegate to other class loaders, the application class loader for example. In other words, classes in named modules defined to class loaders other than the platform class loader and its ancestors may be visible to the platform class loader.&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;System class loader&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;It is also known as application class loader and is distinct from the platform class loader. The system class loader is typically used to define classes on the application class path, module path, and JDK-specific tools. The platform class loader is a parent or an ancestor of the system class loader that all platform classes are visible to it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;更多细节参考：
&lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/lang/ClassLoader.html&quot;&gt;JDK9-Docs-ClassLoader&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="Scroll" /><summary type="html">笔记</summary></entry><entry><title type="html">JVM-Tools</title><link href="http://localhost:4000/JVM-Tools" rel="alternate" type="text/html" title="JVM-Tools" /><published>2021-01-13T00:00:00+08:00</published><updated>2021-01-13T00:00:00+08:00</updated><id>http://localhost:4000/JVM-Tools</id><content type="html" xml:base="http://localhost:4000/JVM-Tools">&lt;h1 id=&quot;jvm相关的工具们&quot;&gt;JVM相关的工具们&lt;/h1&gt;

&lt;h2 id=&quot;java_homebin-下面白送的工具们&quot;&gt;JAVA_HOME/bin 下面白送的工具们&lt;/h2&gt;
&lt;p&gt;这些工具分为三类：商业授权工具，正式支持工具，试验性工具。&lt;/p&gt;

&lt;p&gt;正式支持和试验性工具就不提了，商业授权的工具要求商业环境中使用付费，个人开发环境是免费的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/toc.html&quot;&gt;工具的文档们&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不过这些工具的jdk8版本的在MacOS下很多都有bug，基本只要有Attach to pid的动作的都会崩， &lt;a href=&quot;https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8160376&quot;&gt;JDK-8160376:DebuggerException: Can’t attach symbolicator to the process&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;而且这bug还是到了jdk9才修复，然后sdkman现在除了8就是11以上的版本，一言难尽。&lt;/p&gt;

&lt;p&gt;反正从jdk9开始就模块化了，本地环境实在不行就用jdk11的工具去调试好了…&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;jps: JVM Process Status Tool&lt;/p&gt;

    &lt;p&gt;类似linux命令中的ps，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类(Main Class，main()函数所在的类)名称以及这些进程的本地虚拟机唯一ID(LVM-ID，Local Virtual Machine Identifier)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;jstat: JVM Statistics Monitoring Tool&lt;/p&gt;

    &lt;p&gt;顾名思义，JVM状态监控工具。&lt;/p&gt;

    &lt;p&gt;不同的虚拟机orJDK提供的jstat有些微不同，比如有的是有永久代的，有的已经没有永久代改成元空间了之类的。&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html&quot;&gt;jstat-doc-jdk8&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;jinfo: Configuration Info for Java&lt;/p&gt;

    &lt;p&gt;这个是实时查看和修改JVM参数的。
jinfo就能遇到之前说的那个bug，不过可以单独开个shell利用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sdkman use java 11.xxx&lt;/code&gt;绕过这个bug去调试。&lt;/p&gt;

    &lt;p&gt;下面给出一个打印 Eclipse 启动时JVM参数的例子，其实我顺便试了试idea，发现Eclipse用的是G1GC，idea用的是CMSGC。&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jinfo -flags 49522
VM Flags:
-XX:CICompilerCount=4 -XX:ConcGCThreads=2 -XX:G1HeapRegionSize=1048576 -XX:InitialHeapSize=268435456 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=2147483648 -XX:MaxNewSize=1287651328 -XX:MinHeapDeltaBytes=1048576 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseG1GC -XX:+UseStringDeduplication
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;jmap: Memory Map for Java&lt;/p&gt;

    &lt;p&gt;用于生成堆转储快照,生成的文件可以通过另一个工具jhat来分析，不过一般来说都是把这个文件从服务器上下载到本地然后使用其他可视化工具来分析，因为这个过程可漫长了，当然如果你本地机器内存比服务器的还小，最好找一台内存至少跟服务器内存差不多的机器。&lt;/p&gt;

    &lt;p&gt;比如你先启动自己的IDE，假设是Eclipse，然后通过jps拿到Eclipse的pid，再通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jmap -dump:format=b,file=eclipse.bin 55555&lt;/code&gt;生成快照，最后通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jhat eclipse.bin&lt;/code&gt;读取文件。&lt;/p&gt;

    &lt;p&gt;文件读取完成之后会返回：&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Snapshot resolved.
Started HTTP server on port 7000
Server is ready.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;这时候你打开&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1:7000&lt;/code&gt;就可以看到快照的内容了，可读性极差，不建议使用jhat。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;jstack：Stack Trace for Java&lt;/p&gt;

    &lt;p&gt;用于生成虚拟机当前时刻的线程快照，快照的内容就是线程正在执行的方法栈的集合，跟Thread.getAllStackTraces()方法的功能差不多。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Scroll" /><summary type="html">JVM相关的工具们</summary></entry><entry><title type="html">GC</title><link href="http://localhost:4000/GC" rel="alternate" type="text/html" title="GC" /><published>2021-01-10T00:00:00+08:00</published><updated>2021-01-10T00:00:00+08:00</updated><id>http://localhost:4000/GC</id><content type="html" xml:base="http://localhost:4000/GC">&lt;h1 id=&quot;什么是gc&quot;&gt;什么是GC&lt;/h1&gt;

&lt;p&gt;GC short for Garbage Collection.&lt;/p&gt;

&lt;p&gt;笼统的说回收那些被“没用的数据”所占用的内存，就是GC。&lt;/p&gt;

&lt;p&gt;所有的动态分配内存的语言都要考虑GC的灵魂三问：&lt;/p&gt;

&lt;p&gt;什么东西需要回收？什么时候回收？用什么方法回收？&lt;/p&gt;

&lt;p&gt;经过几十年的发展，现在对于这灵魂三问已经有了很多非常成熟的技术，绝大部分时候我们都不用关心JVM在GC这里都干了些啥。&lt;/p&gt;

&lt;p&gt;那为啥要学GC呢？&lt;/p&gt;

&lt;p&gt;&lt;del&gt;因为面试要问&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;因为当你需要排查内存溢出、内存泄露、GC导致系统响应时间长等等问题时，总要知道JVM那个黑盒子里都干了点啥才能分析不是。&lt;/p&gt;

&lt;h2 id=&quot;什么东西需要gc&quot;&gt;什么东西需要GC？&lt;/h2&gt;

&lt;p&gt;对于Java而言，讨论内存相关的问题自然离不开运行时数据区的基础知识。&lt;/p&gt;

&lt;p&gt;RuntimeDataArea中主要包含两类内存：一类是被线程私有的，比如 Program Counter Register、VM Stack等等；另一类则是共享内存，比如 Heap、Method Area啥的。&lt;/p&gt;

&lt;p&gt;被线程私有的这些内存都是，其大小基本都是“固定”的，比如 VM Stack中每个栈帧需要多少内存，在编译期基本就确定了，其生命周期是随线程生灭的，线程死掉它占用的内存自然也就释放了，所以无需过多考虑。&lt;/p&gt;

&lt;p&gt;而被线程共享的这部分内存则充满了不确定性。
比如所有类的实例、数组啥的都在 Heap 里分配，而一个Java应用会在运行时创建多少对象根本不可预知，这部分需要动态分配内存，也就需要动态回收内存。&lt;/p&gt;

&lt;p&gt;所以GC的主要关注点也在这里。&lt;/p&gt;

&lt;p&gt;换句说话，无论是Lisp还是Java，要确定什么东西需要回收，首先先找到需要动态分配的地方。&lt;/p&gt;

&lt;h3 id=&quot;对方法区进行gc&quot;&gt;对方法区进行GC&lt;/h3&gt;

&lt;p&gt;方法区比较特别，JVMS中提到过不强制要求JVM对方法区实现GC，这个主要是因为回收条件很苛刻，然后还回收不了多少内存，性价比比较低。&lt;/p&gt;

&lt;p&gt;这部分的GC目标主要是两部分内容：1. 废弃的常量 2. 不再使用的类型&lt;/p&gt;

&lt;p&gt;常量比较简单，比如”lament”这个字符串，如果没有任何一个String的值是它，并且JVM肯定也用不到这个字符串，那么就会被从常量池中扫地出门。&lt;/p&gt;

&lt;p&gt;但是判定不再使用的类就很麻烦了。&lt;/p&gt;

&lt;p&gt;首先，这个类的所有实例（包括其派生子类的实例）都已经被回收啦；然后这个类的加载器也被回收啦（这个就很少见了）；然后这个类对应的 java.lang.Class 对象也没有引用了，并且也没办法通过反射访问该类。以上所有条件都满足的时候，也只是允许回收，不是一定会回收。&lt;/p&gt;

&lt;p&gt;这种对类的回收，也叫类型卸载，在大量使用反射，CGLib，动态代理、JSP、OSGi这些场景里才需要JVM具备类型卸载的能力。&lt;/p&gt;

&lt;h2 id=&quot;用什么方法gc&quot;&gt;用什么方法GC？&lt;/h2&gt;

&lt;p&gt;确定了需要回收的主角，接下来就介绍一下回收的方法，至于什么时候回收，需要结合回收方法来确定合适的时机，所以最后聊啥时候回收。&lt;/p&gt;

&lt;p&gt;回收的方法也要分两部分来讨论&lt;/p&gt;

&lt;h3 id=&quot;如何确定哪些是回收对象&quot;&gt;如何确定哪些是回收对象&lt;/h3&gt;

&lt;p&gt;以下介绍两种标记待回收对象的方法。&lt;/p&gt;

&lt;h4 id=&quot;引用计数法&quot;&gt;引用计数法&lt;/h4&gt;

&lt;p&gt;这个办法就是给对象加个&lt;strong&gt;引用计数器&lt;/strong&gt;，每多一个引用，计数器就+1，引用失效就-1，如果计数器的值为0，那就说明没人再用它了，没用了就可以回收了。&lt;/p&gt;

&lt;p&gt;这个办法简单高效，虽然计数器带来了一丢丢额外的内存开销，但是很好用。 然而主流JVM的实现里没有用这个办法的，主要是很难解决对象之间互相引用的情况。&lt;/p&gt;

&lt;h4 id=&quot;可达性分析reachability-analysis法&quot;&gt;可达性分析(Reachability Analysis)法&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;其实这又是数学概念 =，=  妈蛋有钱之后第一件事：回炉去念个数学系&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种方法就是从Root出发，根据引用关系向下搜索，如果搜到头找到了，叫做可达，没找到，叫做不可达。
搜素的路径通常被称为 Reference Chain。&lt;/p&gt;

&lt;p&gt;当从Root到某对象不可达时，说明某对象没用啦，然后就可以回收啦,但是不一定真的被回收。&lt;/p&gt;

&lt;h5 id=&quot;二次标记&quot;&gt;二次标记&lt;/h5&gt;

&lt;p&gt;当一个对象被判定为不可达时，它会被第一次标记，然后JVM会对其进行一次判定，看这个对象是否有必要执行finalize()，没必要的话直接去等gc。&lt;/p&gt;

&lt;p&gt;如果需要执行，那么这个对象会被放入F-Queue中，之后JVM会启动一个优先级比较低的Finalizer线程去执行这个队列里的对象的finalize()。&lt;/p&gt;

&lt;p&gt;由于这个线程优先级很低，也不保证队列里那些对象的finalize()都执行完，所以JVM还会对这个队列进行二次标记，如果在二次标记前队列中的某个对象又被赋值给其他变量了，它会在二次标记的时候被移出队列，剩下的就等着被GC。&lt;/p&gt;

&lt;h5 id=&quot;可作为gc-roots的对象们&quot;&gt;可作为GC Roots的对象们&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在方法区中常量引用的对象，譬如字符串常量池(String Table)里的引用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在本地方法栈中JNI(即通常所说的Native方法)引用的对象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java虚拟机内部的引用&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如基本数据类型对应的Class对象，一些常驻的异常对象(比如NullPointExcepiton、OutOfMemoryError)等，还有系统类加载器。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;所有被同步锁(synchronized关键字)持有的对象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;临时工Root对象&lt;/p&gt;

    &lt;p&gt;除了上述的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;如何回收对象--gc算法&quot;&gt;如何回收对象 ｜ GC算法&lt;/h3&gt;

&lt;h4 id=&quot;名词解释&quot;&gt;名词解释&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Minor GC/Young GC&lt;/p&gt;

    &lt;p&gt;指目标只是新生代的垃圾收集。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Major GC/Old GC&lt;/p&gt;

    &lt;p&gt;通常指目标只是老年代的垃圾收集，某些情况下Major GC有时也指整堆GC。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Full GC&lt;/p&gt;

    &lt;p&gt;收集整个Java堆和方法区的垃圾收集。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mixed GC&lt;/p&gt;

    &lt;p&gt;指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 集器会有这种行为。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Partial GC&lt;br /&gt;
指目标不是完整收集整个Java堆的垃圾收集，前面的Minor GC等都属于部分收集。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;分代假说&quot;&gt;分代假说&lt;/h4&gt;
&lt;p&gt;很多JVM的都是基于分代收集的理论来进行GC的。&lt;/p&gt;

&lt;p&gt;分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;弱分代假说(Weak Generational Hypothesis)&lt;br /&gt;
  绝大多数对象都是朝生夕灭的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;强分代假说(Strong Generational Hypothesis)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;熬过越多次垃圾收集过程的对象就越难以消亡。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;跨代引用假说(Intergenerational Reference Hypothesis)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第三条假设则是基于上面两条的推论，存在互相引用的两个对象通常会同时生存或同时消亡，因此，跨代引用相对于同代引用来说仅占极少数。&lt;/p&gt;

&lt;p&gt;通常分代至少会分为新生代和老年代两代，当一个处于新生代的对象存在跨代引用关系时，那么引用它的对象一定是在老年代，由于老年代对象很难消亡，被其引用的对象自然也会进入老年代，此时跨代引用关系就消失了。&lt;/p&gt;

&lt;p&gt;第三条假说主要是为了解释为什么JVM不会为了跨代引用而去扫描整个老年代，只要在新生代上建立一个Remembered Set，这个记忆集会将老年代分为若干区域，并且标记出哪个区域存在跨代引用。当JVM开始对新生代进行GC（也叫Minor GC）时，只有被标记区域的老年代对象才会加入GC Roots，从而避免扫描整个老年代。&lt;/p&gt;

&lt;p&gt;基于第一、第二假说，很多常用的垃圾收集器都确立了以下设计原则：&lt;/p&gt;

&lt;p&gt;收集器应该将Java堆划分 出不同的区域，然后将回收对象依据其年龄(年龄即对象熬过垃圾收集过程的次数)分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间;如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。&lt;/p&gt;

&lt;p&gt;根据这个原则就可以完成对内存/对象们的划分，产生不同分区之后自然也就可以对不同的区域进行特定的回收，比如Minor GC,Major GC，Full GC等等。&lt;/p&gt;

&lt;p&gt;同时也因此发展出了以下几种具有针对性的垃圾回收算法。&lt;/p&gt;

&lt;h4 id=&quot;标记-清除算法-mark-sweep&quot;&gt;标记-清除算法 Mark-Sweep&lt;/h4&gt;

&lt;p&gt;Mark-Sweep是很古老，也是很基础的GC算法，现代的很多GC算法都是在其基础上进化来的。&lt;/p&gt;

&lt;p&gt;最早出现的GC算法，标记就是通过之前说的引用计数法or可达性分析法来对待回收对象进行标记（反过来标记存活，回收未标记对象也是一样的）， 然后将所有被标记的对象清除掉，从而完成回收。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;缺陷&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主要是两个缺点：&lt;/p&gt;

&lt;p&gt;执行效率不稳定，需要标记-清除的对象越多，GC就越慢。&lt;/p&gt;

&lt;p&gt;内存碎片化严重，当大对象无法找到连续内存时会提前触发GC，如果GC之后还是不够…&lt;/p&gt;

&lt;h4 id=&quot;标记-复制算法&quot;&gt;标记-复制算法&lt;/h4&gt;

&lt;p&gt;比如标记-复制 Semispace Copying,这个也挺老的，1969年诞生的。&lt;/p&gt;

&lt;p&gt;这个算法其实不如叫&lt;strong&gt;标记-清除-复制&lt;/strong&gt;算法， &lt;strong&gt;标记-清除&lt;/strong&gt;跟前面一样，主要说说&lt;strong&gt;复制&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这种算法会将内存划分为大小相等的两块，假设一个叫A区，一个叫B区。一开始内存分配的时候在A区进行分配，标记也只标记A区，当GC开始，清除结束，还活着的对象会被复制到B区，然后A区整个清空。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;优点&lt;/p&gt;

    &lt;p&gt;完全克服了内存碎片的问题，并且由于完全没有内存碎片，所以分配内存也很简单，移动堆指针就完了。并且当绝大部分对象均可回收时，复制也只需要复制少量存活对象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缺点&lt;/p&gt;

    &lt;p&gt;内存上来就浪费了一半。存活对象多的时候复制的代价也大。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以目前的实际应用中并不会真的采用 1:1 的比例对内存进行划分，基于前面提过的假说，98%的对象都活不过第一轮收集，所以大部分时候划分是 8:2 or 8:1:1 。&lt;/p&gt;

&lt;p&gt;这种方法常用于对新生代进行收集，其中留存下来的那些对象通常就被扔去老年代或者Survivor之类的地方，比如8:1:1的Appel式回收，8为Eden，1为Survivor，两个Survivor其中一个被浪费掉，当一次Minor GC执行完后，如果Survivor里放不下，就会让老年代分担多出来的对象，这种分担被称作分配担保(Handle Promotion)。&lt;/p&gt;

&lt;h4 id=&quot;标记-整理算法-mark-compact&quot;&gt;标记-整理算法 Mark-Compact&lt;/h4&gt;

&lt;p&gt;这个算法的标记阶段还是跟&lt;strong&gt;标记-清除&lt;/strong&gt;一样，区别在于，标记完之后不先清除，而是将存活对象进行移动，向内存的一端对齐，也就是把存活对象都整理到一块儿去，除此之外的全部清除。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;优点
内存空间不会被浪费，也没有内存碎片。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缺点&lt;br /&gt;
“整理”是一个非常重的操作，不光要在内存里移动对象，还要更新这些对象的引用，并且“整理”的时候应用啥也不能干，俗称“Stop the world”。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;gc算法的实现各种收集器-collecters&quot;&gt;GC算法的实现：各种收集器 Collecters&lt;/h3&gt;

&lt;p&gt;TODO 考虑根据时间线/进化史来整理各种收集器。&lt;/p&gt;

&lt;h5 id=&quot;serial-收集器&quot;&gt;Serial 收集器&lt;/h5&gt;

&lt;p&gt;最基础的收集器，除了单线程工作之外，它更强调当它进行GC时，其他工作线程必须全部暂停，一直到收集完成，俗称’Stop the world’。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;算法&lt;/p&gt;

    &lt;p&gt;对新生代收集时采用标记-复制算法，对老年代收集时采用标记-整理算法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;应用&lt;br /&gt;
jdk1.3.1 之前是 HotSpot 虚拟机回收新生代时的唯一收集器。
现在更适合用于新生代内存容量一两百兆以内的客户端，因为只要新生代的规模不大并且回收行为不频繁时，几十毫秒最多一两百毫秒的停顿是完全可以接受的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;parnew-收集器&quot;&gt;ParNew 收集器&lt;/h5&gt;

&lt;p&gt;Serial 收集器的多线程版本，可以使用多条线程进行垃圾收集，除了多线程之外跟Serial收集器基本一致，包括Stop the world。&lt;/p&gt;

&lt;p&gt;但是它有一个性能无关的特点是，除 Serial 收集器之外，只有它可以与CMS收集器配合工作。&lt;/p&gt;

&lt;p&gt;所以运行在-Server模式下的HotSpot虚拟机（JDK7前）通常都是使用ParNew收集器来对新生代进行回收。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;历史故事 -节选自《深入JVM虚拟机》
在JDK 5发布时，HotSpot推出了一款在强交互应用中几乎可称为具有划时代意义的垃圾收集器 ——CMS收集器。这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，它首次 实现了让垃圾收集线程与用户线程(基本上)同时工作。&amp;lt;/br&amp;gt;
遗憾的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel
Scavenge配合工作[1]，所以在JDK 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者 Serial收集器中的一个。ParNew收集器是激活CM S后(使用-XX:+UseConcMarkSweep GC选项)的默认新生代收集器，也可以使用-XX:+/-UseParNewGC选项来强制指定或者禁用它。&amp;lt;/br&amp;gt;
可以说直到CMS的出现才巩固了ParNew的地位，但成也萧何败也萧何，随着垃圾收集器技术的不断改进，更先进的G1收集器带着CMS继承者和替代者的光环登场。G1是一个面向全堆的收集器，不再需要其他新生代收集器的配合工作。所以自JDK 9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。官方希望它能完全被G1所取代，甚至还取消了ParNew加 Serial Old以及Serial加CMS这两组收集器组合的支持(其实原本也很少人这样使用)，并直接取消了 -XX:+UseParNewGC 参数，这意味着ParNew和CMS从此只能互相搭配使用，再也没有其他收集器能够和它们配合了。读者也可以理解为从此以后，ParNew合并入CMS，成为它专门处理新生代的组成部分。ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;parallel-scavenge-收集器&quot;&gt;Parallel Scavenge 收集器&lt;/h5&gt;
&lt;p&gt;Parallel 并行，Scavenge 搜索，直译就是并行搜索收集器。&lt;/p&gt;

&lt;p&gt;这款收集器主要关注点是：吞吐量可控。（其他收集器关注的是停顿时间尽量短）&lt;/p&gt;

&lt;p&gt;这里吞吐量的计算公式为： 吞吐量 = 用户代码运行时间 / (用户代码运行时间 + 运行GC花费时间)。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;算法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;标记-复制&lt;/p&gt;

&lt;h5 id=&quot;serial-old收集器&quot;&gt;Serial Old收集器&lt;/h5&gt;
&lt;p&gt;Serial收集器的老年代版本，通常与Parallel Scavenge收集器搭配使用，或者作为CMS收集器发生失败时的后备方案。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;节选
需要说明一下，Parallel Scavenge收集器架构中本身有PS M arkSweep收集器来进行老年代收集，并非 直接调用Serial Old收集器，但是这个PS MarkSweep收集器与Serial Old的实现几乎是一样的，所以在官
方的许多资料中都是直接以Serial Old代替PS MarkSweep进行讲解，这里笔者也采用这种方式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;算法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;标记-整理&lt;/p&gt;

&lt;h5 id=&quot;parallel-old收集器&quot;&gt;Parallel Old收集器&lt;/h5&gt;

&lt;p&gt;Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，主要用来配合Parallel Scavenge收集器搭配使用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;算法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;标记-整理&lt;/p&gt;

&lt;h5 id=&quot;concurrent-mark-sweep-cms收集器&quot;&gt;Concurrent Mark Sweep CMS收集器&lt;/h5&gt;

&lt;p&gt;并发的，采用标记清除算法的收集器。
该收集器主要关注目标是停顿时间短。
它的整个收集过程相对前面几种也复杂一些，为了尽可能的缩短停顿时间，他把标记这个阶段拆分成了好几步完成，其中相对耗时的步骤不需要stop the world。&lt;/p&gt;

&lt;p&gt;TODO cms还是单独开一篇&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;缺点&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;占用cpu的计算资源，默契启动线程数是 核心数+3/4,也就是说最好是四核以上的cpu&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;无法处理“浮动垃圾”(FloatingGarbage)，可能出现Con-current Mode Failure，然后导致一次full gc.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;碎片内存太多可能会提前触发full gc&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;收集过程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个感觉也可以摘出来放到CMS单独成篇。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;初始标记(CMS initial mark)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;并发标记(CMS concurrent mark)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重新标记(CMS remark)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;并发清除(CMS concurrent sweep)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;算法&lt;br /&gt;
标记-清除&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;garbage-first-g1收集器&quot;&gt;Garbage First (G1)收集器&lt;/h5&gt;

&lt;p&gt;全功能的垃圾收集器(Fully-Featured Garbage Collector)&lt;/p&gt;

&lt;p&gt;TODO 这个肯定得单独开一篇。&lt;/p&gt;

&lt;p&gt;G1收集器开始面向回收集进行GC，回收集（collection set）可以是堆的任何部分（不在乎是什么代）。&lt;/p&gt;

&lt;p&gt;它GC的标准是哪里垃圾多就回收哪里，这个就是Mixed GC模式。&lt;/p&gt;

&lt;p&gt;G1不再将内存划分为各个代，而是将连续的堆划分成多个大小相等、相互独立的 Region，每个Region可以根据需要，作为新生代或者老年代。&lt;/p&gt;

&lt;p&gt;收集器会根据Region所代表的功能不同来采用不同的策略。并且为了应对大对象的情况，G1准备了Humongous区，所以超过Region容量一半大小的对象，都视为大对象，都放在Humongous区，如果对象大到超过Humongous，则会放在几个连续的Humongous区中。
Humongous区是被视为老年代的一部分。&lt;/p&gt;

&lt;h5 id=&quot;zgc&quot;&gt;ZGC&lt;/h5&gt;
&lt;p&gt;jdk 11开始加入的试验性收集器，先，就知道个名字算了。&lt;/p&gt;

&lt;h3 id=&quot;内存分配&quot;&gt;内存分配&lt;/h3&gt;

&lt;p&gt;Java技术体系的自动内存管理，最根本的目标是自动化地解决两个问题:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;自动给对象分配内存&lt;/li&gt;
  &lt;li&gt;自动回收分配给对象的内存&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;自动分配内存&quot;&gt;自动分配内存&lt;/h4&gt;

&lt;p&gt;首先，对象通常优先分配新生代，特殊情况下，如大对象（占据大量连续内存空间的Java对象）会直接进老年代。&lt;/p&gt;

&lt;p&gt;然后，对象在内存中是有年龄的，JVM在对象头里存储了他们的年龄，每活过一次GC年龄就涨一岁，年龄大于某个值（默认15）后就进入老年代。&lt;/p&gt;

&lt;p&gt;除了年龄符合可以“晋升”老年代之外，某些虚拟机规定，当同年龄对象占用Survivor空间一半以上的时候，也会进入老年代。&lt;/p&gt;

&lt;p&gt;最后还有空间分配担保机制，Eden+双Survivor的分配方式下（标记复制算法）是有可能出现存活的对象们的总大小超过Survivor空间大小的。&lt;/p&gt;

&lt;h2 id=&quot;什么时候gc&quot;&gt;什么时候GC？&lt;/h2&gt;

&lt;p&gt;准确的说这部分应该叫，在什么情况下会触发什么GC。&lt;/p&gt;

&lt;p&gt;这部分先略，不同收集器的触发条件都不太相同。&lt;/p&gt;

&lt;h2 id=&quot;引用&quot;&gt;引用&lt;/h2&gt;

&lt;p&gt;前面各种提到引用，引用到底是啥。&lt;/p&gt;

&lt;p&gt;最传统的定义就是：如果reference类型的数据中存储的是另一块内存的起始地址，那么这个reference类型的数据就是某个东西（就是前半句的另一块内存里存的东西）的引用。&lt;/p&gt;

&lt;p&gt;传统概念下的引用非常直观，要么你是他的引用，要么不是，但是实际情况下，尤其是讨论GC的时候，这种区分就不够了，没有引用的对象还好说，回收了就完了，但是有引用的对象有一些我们希望在内存足够的情况下先留着，实在不够的（比如gc一次之后仍然内存不足）情况下，即便它还有引用也先回收了。&lt;/p&gt;

&lt;p&gt;所以自JDK1.2之后，Java把引用的概念扩展成了四种。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;强引用 Strongly Reference&lt;/p&gt;

    &lt;p&gt;在程序代码之中普遍存在的引用赋值, 比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object obj = new Object()&lt;/code&gt;这种。
无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软引用 Soft Reference&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;软引用是用来描述一些还有用，但非必须的对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;只被软引用关联着的对象，在系统将要发生内 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;弱引用 Weak Reference&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只 被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;只能活到下一次GC开始前。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;虚引用 Phantom Reference&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供 了PhantomReference类来实现虚引用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。&lt;/p&gt;</content><author><name></name></author><category term="Scroll" /><summary type="html">什么是GC</summary></entry><entry><title type="html">Stack Frame - 草稿</title><link href="http://localhost:4000/stack-based-architecture" rel="alternate" type="text/html" title="Stack Frame - 草稿" /><published>2021-01-04T00:00:00+08:00</published><updated>2021-01-04T00:00:00+08:00</updated><id>http://localhost:4000/stack-based-architecture</id><content type="html" xml:base="http://localhost:4000/stack-based-architecture">&lt;blockquote&gt;
  &lt;p&gt;The JVM uses a stack based architecture.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;数据结构里的栈stack&quot;&gt;数据结构里的栈(stack)&lt;/h2&gt;

&lt;p&gt;先抛开语言环境啥的，单聊一下数据结构中的栈是个啥(stack)。&lt;/p&gt;

&lt;p&gt;Stack 的结构和性质跟网球罐子差不多。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lament-z.com/assets/images/tennis.png&quot; alt=&quot;tennis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每次我们想取出一个球只能从最上面拿，想拿最下面的球就必须先把上面的先拿完。&lt;/p&gt;

&lt;p&gt;往里装球的时候也是，最先放进去的在最下面，最后放进去的在最上面。&lt;/p&gt;

&lt;p&gt;对应到数据结构中这就是 Stack。&lt;/p&gt;

&lt;p&gt;网球罐子开口的那一端，对应 Stack 的 top。&lt;/p&gt;

&lt;p&gt;向 Stack 中添加元素（也就是往里塞球），叫做入栈，push。&lt;/p&gt;

&lt;p&gt;从 Stack 中取出元素(往外拿球)，叫出栈，pop。&lt;/p&gt;

&lt;p&gt;LIFO，Last in first out。&lt;/p&gt;

&lt;h2 id=&quot;栈帧-stack-frame&quot;&gt;栈帧 Stack Frame&lt;/h2&gt;

&lt;p&gt;JVM最基本的执行单元为方法。&lt;/p&gt;

&lt;p&gt;而 Stack Frame 是支持方法调用和方法执行背后的数据结构。&lt;/p&gt;

&lt;h3 id=&quot;组成&quot;&gt;组成&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://lament-z.com/assets/images/JVM/Stack Frame Diagram.jpg&quot; alt=&quot;Stack Frame&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Stack Frame中包含 局部变量表，操作数栈，以及其他一些栈帧数据。&lt;/p&gt;

&lt;h4 id=&quot;局部变量表-local-variables-table&quot;&gt;局部变量表 local variables Table&lt;/h4&gt;

&lt;p&gt;TODO  复用槽啥的也想略。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;是什么&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;局部变量表(Local Variables Table)是一组变量值的存储空间，用于存放方法参数和方法内部定义 的局部变量。在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方 法所需分配的局部变量表的最大容量。&lt;/p&gt;

&lt;p&gt;所谓的一组变量值具体是指：方法参数，方法内部定义的那些个局部变量。&lt;/p&gt;

&lt;p&gt;局部变量表的最小组成部分叫做变量槽（Variable Slot）。&lt;/p&gt;

&lt;p&gt;它的大小要能存放一个X类型的数据，这个X指的是：6种基础元素类型的JVM版（除去double long）+对象实例的引用+returnAddress（比较少见）。&lt;/p&gt;

&lt;p&gt;对象实例的引用类型的长度，跟虚拟机是32位/64位相关，如果是64位还跟有没有开启某些对象指针压缩的优化有关。&lt;/p&gt;

&lt;p&gt;除了八种大小不会超过32位的数据类型之外，还有double和long这俩64位的。
JVM存储64位数据类型的方式是，通过高位对其的方式将其分配到俩连续的槽中。&lt;/p&gt;

&lt;p&gt;32位的数据类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;怎么用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JVM通过索引定位的方式使用局部变量表。&lt;/p&gt;

&lt;p&gt;索引范围：[0，slotMax]。&lt;/p&gt;

&lt;p&gt;访问32位数据时，索引n就代表第n个槽。
访问64位时，索引n则是n和n+1俩槽，并且不允许单独访问其中一个。&lt;/p&gt;

&lt;p&gt;当方法被调用时，JVM会使用 局部变量表 来完成参数值到参数列表的传递过程。&lt;/p&gt;

&lt;p&gt;即实参到型参的传递。&lt;/p&gt;

&lt;p&gt;如果执行的是实例方法（非static），局部变量表的0槽里默认存放 用于传递方法所属对象实例的引用。（方法里面写的this就是它）。
其余的参数则按照参数表顺序排列，从槽1开始依次占坑。&lt;/p&gt;

&lt;p&gt;参数表分配完之后，再根据方法内部定义的变量顺序和作用域分配其余的槽。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;复用槽&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了尽可能节省栈帧耗用的内存空间，局部变量表中的变量槽是可以重用的。&lt;/p&gt;

&lt;p&gt;方法中的变量的作用域不一定覆盖整个方法体，当pc计数器的值超过了某个变量的作用域范围时，这个槽就可以重用。&lt;/p&gt;

&lt;p&gt;次重用的设计虽然节省了栈空间，但是偶尔会影响到GC。&lt;/p&gt;

&lt;p&gt;影响主要产生于重用这里，重用并不是超出作用域范围之后立刻清空，而是等到需要的时候才会清。
在槽被清之前，这个变量虽然已经超出作用域范围了，但是引用还在，gc的时候由于仍然保持着引用，就依然属于可达。&lt;/p&gt;

&lt;h3 id=&quot;操作数栈操作栈-operand-stack&quot;&gt;操作数栈/操作栈 Operand Stack&lt;/h3&gt;

&lt;p&gt;也是个栈，也有槽，槽的大小跟前面一致，栈的最大深度是编译器在做数据流分析的时候保证不超过max_stacks的最大值。&lt;/p&gt;

&lt;h4 id=&quot;运行流程&quot;&gt;运行流程&lt;/h4&gt;

&lt;p&gt;一个方法刚开始执行时，OperandStack是空的，方法执行的过程中会有各种字节码指令对OperandStack进行入栈、出栈操作。&lt;/p&gt;

&lt;p&gt;比如 1+2 ,就是先把俩数入栈，然后字节码指令iadd把这俩数出栈，然后相加，最后把相加的结果再入栈。&lt;/p&gt;

&lt;p&gt;抽象模型中 两个StackFrame是相互独立的，但是虚拟机的实现里通常会进行优化处理，通过将不同的栈帧部分重叠，让下面栈帧的部分操作数栈和上面栈帧的部分比局部变量表重叠。&lt;/p&gt;

&lt;p&gt;这样即可以节约空间，还可以在方法调用时直接公用一部分数据，避免进行额外的参数复制传递。&lt;/p&gt;

&lt;h3 id=&quot;frame-data-reference-to-runtime-constant-pool&quot;&gt;Frame data: Reference to Runtime Constant Pool&lt;/h3&gt;

&lt;p&gt;每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的&lt;strong&gt;动态连接&lt;/strong&gt;(Dynamic Linking)。&lt;/p&gt;

&lt;p&gt;类加载的时候提到过&lt;strong&gt;解析阶段&lt;/strong&gt;会将 符号引用 转化为 直接引用，这种&lt;strong&gt;叫静态解析&lt;/strong&gt;。
还要一部分 符号引用 在是在运行时转化为 直接引用，这个就是动态链接Dynamic Linking。&lt;/p&gt;

&lt;h3 id=&quot;frame-data-returnaddress&quot;&gt;Frame data: returnAddress&lt;/h3&gt;

&lt;p&gt;TODO returnAddress想略过不表。&lt;/p&gt;

&lt;p&gt;这个东西属于上古遗留产物，是一种特殊的类型，给Java虚拟机的jsr，ret和jsr_w指令（§jsr，§ret，§jsr_w）用的，主要是处理异常。
现在异常处理都是用异常表。​
一个方法开始执行后，有两种退出方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一种是正常退出 Normal Method Invocation Completion&lt;/p&gt;

    &lt;p&gt;就正常执行完，要么结束（void），要么返回个返回值给它的上一层调用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一种是执行过程中遇到异常 Abrupt Method Invocation Completion&lt;/p&gt;

    &lt;p&gt;方法没执行完，然后代码中出现了未妥善处理的异常，或者jvm内部出错，反正只要是在该方法异常表里没找到匹配的异常处理器，就直接导致方法退出。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;无论是那种方式退出，退出之后必须返回最初方法被调用时的位置，程序才能继续运行。
正常退出时，一般就是主调方法pc计数器的值就是返回地址。&lt;/p&gt;

&lt;p&gt;方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有:恢复上层方法的 局部变量表和操作数栈，把返回值(如果有的话)压入调用者栈帧的操作数栈中，调整PC计数器的值 以指向方法调用指令后面的一条指令等。笔者这里写的“可能”是由于这是基于概念模型的讨论，只有 具体到某一款Java虚拟机实现，会执行哪些操作才能确定下来。&lt;/p&gt;

&lt;h3 id=&quot;frame-data-others&quot;&gt;Frame data: others&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TODO 这部分也想略。&lt;/p&gt;</content><author><name></name></author><category term="Scroll" /><summary type="html">The JVM uses a stack based architecture.</summary></entry><entry><title type="html">JVM-RuntimeDataArea</title><link href="http://localhost:4000/JVM-Runtime-Data-Area" rel="alternate" type="text/html" title="JVM-RuntimeDataArea" /><published>2020-12-28T00:00:00+08:00</published><updated>2020-12-28T00:00:00+08:00</updated><id>http://localhost:4000/JVM-Runtime-Data-Area</id><content type="html" xml:base="http://localhost:4000/JVM-Runtime-Data-Area">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;《Java虚拟机规范》定义了如下几个运行时数据区：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lament-z.com/assets/images/JVM/runtime-data-area-v1.jpg&quot; alt=&quot;RT Data Areas Overview&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中一些区域随着线程的启动和结束而创建和销毁，另一部分则随着JVM的启动而一直存在到JVM关闭。&lt;/p&gt;

&lt;h2 id=&quot;使用方法&quot;&gt;使用方法&lt;/h2&gt;

&lt;p&gt;一边画图一边看，画一块看一块。
  过完一遍之后，擦了重来，哪里忘了看哪里。&lt;/p&gt;

&lt;h2 id=&quot;详解&quot;&gt;详解&lt;/h2&gt;

&lt;p&gt;下图可以更直观的区分不同数据区域:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lament-z.com/assets/images/JVM/runtime-data-area-v2.jpg&quot; alt=&quot;RT Data Areas with Thread&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从第二张图可以清晰的看出，虚拟机栈(JVM Stack)、本地方法栈(Native Stack)、以及程序计数器(The Program Counter Register)与线程共生共灭。&lt;/p&gt;

&lt;p&gt;而堆（Heap）和方法区（Method Area 也被称作非堆）则被所以线程共享。&lt;/p&gt;

&lt;p&gt;接下来逐个介绍每个区域的功能，按照是否线程隔离，先从与线程共生共灭的几种说起。&lt;/p&gt;

&lt;h3 id=&quot;程序计数器-the-program-counter-register&quot;&gt;程序计数器 (The Program Counter Register)&lt;/h3&gt;

&lt;p&gt;程序计数器，之后简称为PC Register，简单的说就是记录当前线程执行的字节码所在行号的一小块内存，如果线程执行的是本地方法(Native Method)则记录undefined，其生命周期与线程相同。&lt;/p&gt;

&lt;p&gt;JVM的多线程是“分片”式实现：在任意确定时刻，一个处理器(多核CPU则是其中一个核)只都只执行一个线程中的指令（看作一个片）。并发只是不断在各个分片上切换的”假象”。而每个线程的PC Register就是用来保证线程切换后可以正确恢复的关键。&lt;/p&gt;

&lt;p&gt;PC Register的工作就是通过改变PC Register存储的值来选取需要执行的下一条字节码指令。
  程序控制流，如分支、循环、跳转、异常处理、线程恢复等等都依赖这个指示器。&lt;/p&gt;

&lt;h4 id=&quot;内存&quot;&gt;内存&lt;/h4&gt;

&lt;p&gt;其内存大小足够持有一个”return Address”或者是一个指定系统的Native pointer，具体到不同版本JVM的实现里是多大没关心过。&lt;/p&gt;

&lt;h4 id=&quot;异常&quot;&gt;异常&lt;/h4&gt;

&lt;p&gt;唯一一个“规范”中没有定义内存异常的区域。&lt;/p&gt;

&lt;h3 id=&quot;虚拟机栈-jvm-stack&quot;&gt;虚拟机栈 (JVM Stack)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;这部分摘自《深入理解JAVA虚拟机(第三版)》。 &lt;br /&gt;
 虚拟机栈(VM Stack)描述的是Java方法执行的线程内存模型:  &lt;br /&gt;
 每个方法被执行的时候，Java虚拟机都会同步创建一个帧(StackFrame)用于存储局部变量表(Local Variable Array)、操作数栈(Operand Stack)、动态连接、方法出口等信息。
 每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;啥意思呢，先看下图，主要是右半部分，懒得单独做一张 VM Stack 的图了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lament-z.com/assets/images/JVM/RuntimeDataArea-details.jpg&quot; alt=&quot;RT Data Areas with vm stack details&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每当一个新线程启动的时候，JVM就会给这个线程创建一个 VM Stack，而VM Stack把线程的状态存储在栈帧(Stack Frame)中，JVM对 VM Stack 的直接操作就俩：入栈，出栈（Because the Java Virtual Machine stack is never manipulated directly except to push and pop frames, frames may be heap allocated.）。&lt;/p&gt;

&lt;p&gt;无论是我们写的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.out.println(&quot;Hello World&quot;);&lt;/code&gt; 还是别的什么方法，都是基于这个模型完成的。&lt;/p&gt;

&lt;p&gt;”Stack Frame“ ，包括“JVM执行方法时都发生了啥”这里暂时不展开，回头单独开一篇顺便打包上“递归”一起说。&lt;/p&gt;

&lt;p&gt;万一我鸽太久，也可以先看看《Inside the Java Virtual Machine》中的&lt;a href=&quot;https://www.artima.com/insidejvm/ed2/jvm8.html&quot;&gt;The Java Stack&lt;/a&gt;这一节，讲述的非常清晰。&lt;/p&gt;

&lt;h4 id=&quot;内存-1&quot;&gt;内存&lt;/h4&gt;

&lt;p&gt;该区域中内存无需连续。&lt;/p&gt;

&lt;h4 id=&quot;异常-1&quot;&gt;异常&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;当线程申请 VM Stack 的深度超过的规定时，抛 &lt;strong&gt;&lt;em&gt;StackOverflowError&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当 VM Stack 为可拓展型时，线程需要动态扩展自己的 VM Stack，但空余内存不足时；或者当空余内存不足以初始化线程的 VM Stack 时，抛 &lt;strong&gt;&lt;em&gt;OutOfMemoryError&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;本地方法栈-native-stack&quot;&gt;本地方法栈 (Native Stack)&lt;/h3&gt;

&lt;p&gt;跟VM Stack作用差不多，只不过是调用Native方法。
  异常情况也是类似。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;说完了线程隔离的区域，来看看共享的区域：Heap &amp;amp; Method Area。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;堆-heap&quot;&gt;堆 (Heap)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;The heap is the run-time data area from which memory for all class instances and arrays is allocated.   – From JVMS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所有的类的实例，数组啥的都在堆(Heap)上分配。
  提到Heap就免不了说一嘴分代，什么新生代老年代永久代，包括元空间blabla，这些是基于“分代收集理论”or某些JVM具体实现引出的说法，Heap在本篇仅限于“JVMS中规定的Heap”这么一个抽象模型。&lt;/p&gt;

&lt;h4 id=&quot;内存-2&quot;&gt;内存&lt;/h4&gt;

&lt;p&gt;Heap可以是固定大小，也可以是可扩展式的。
  通常遇到的都是可扩展的，通过-Xmx(maximum heap size ) -Xms(minimum heap size，也称为初始 Heap size)来设定其大小。&lt;/p&gt;

&lt;p&gt;关于某些特定的JVM的这类参数啦、这类参数选项都有啥啦、它们的含义啥的可以参考Oracle的&lt;a href=&quot;https://docs.oracle.com/cd/E21764_01/web.1111/e13814/jvm_tuning.htm#PERFM150&quot;&gt;Tuning Java Virtual Machines&lt;/a&gt;文档。&lt;/p&gt;

&lt;p&gt;关于TLAB(Thread Local Allocation Buffer):&lt;/p&gt;

&lt;p&gt;《深入理解JAVA虚拟机(第三版)》里面提到了，为了提升对象分配时效率，Heap中会划分出多个被线程私有的分配缓冲区，这个缓冲区就是TLAB，里面存的依然是对象的实例或Array。说白了就是从大Heap里分几个小Heap给Thread们拿去用，只是优化的手段，Heap还是Heap。&lt;/p&gt;

&lt;h4 id=&quot;异常-2&quot;&gt;异常&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;如果Heap中剩余内存不够分配给实例or数组，并且也没更多的内存让Heap完成扩展时，抛&lt;strong&gt;&lt;em&gt;OutOfMemoryError&lt;/em&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;方法区-method-area&quot;&gt;方法区 (Method Area)&lt;/h3&gt;

&lt;p&gt;方法区 (Method Area，很多资料也用非堆来将它与堆进行区分)用来存储被JVM加载的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;类型信息 TypeInformation&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;常量池 The Constant Pool&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;域信息 Field Information&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法信息 Method Information&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类变量 Class Variables  &lt;br /&gt;
  鉴于我接触的很多人都不这么叫，很多书上也不这么写，稍微解释下啥是类变量。
  举个例子，比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Integer.MAX_VALUE&lt;/code&gt;中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAX_VALUE&lt;/code&gt;这种作为类属性之一，并且被&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt;修饰(是不是public无所谓)，当然还自带初始值的，就是类变量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;各种引用等等&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体细节单独展开。&lt;/p&gt;

&lt;p&gt;这里的部分翻译参考了&lt;a href=&quot;https://www.ituring.com.cn/article/491755&quot;&gt;Java 中 field 和 variable 区别及相关术语解释&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;内存-3&quot;&gt;内存&lt;/h4&gt;

&lt;p&gt;规范中对该区域规定也比较宽松，不需要内存连续，可以是固定大小的也可以是可扩展的。&lt;/p&gt;

&lt;p&gt;还有之前提到的“分代理论”，以前一些JVM按照他们自己的分代设计，用永久代实现了方法区。
  叫永久可能是这部分存贮的都是些比较”固定”的东西，但是不代表&lt;strong&gt;&lt;em&gt;永久代 == 方法区&lt;/em&gt;&lt;/strong&gt;，也不代表该区域就绝对不进行内存回收。&lt;/p&gt;

&lt;h4 id=&quot;异常-3&quot;&gt;异常&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;无法满足新的内存分配需求时,抛&lt;strong&gt;&lt;em&gt;OutOfMemoryError&lt;/em&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;运行时常量区-run-time-constant-pool&quot;&gt;运行时常量区 (Run-Time Constant Pool)&lt;/h3&gt;

&lt;p&gt;它是方法区的一部分，规范规定当JVM创建一个类或者接口时，就为该类或对象构建一个运行时常量池。&lt;/p&gt;

&lt;p&gt;写了半天都不太满意，要么不够清楚，要么不够简洁，先挂着&lt;a href=&quot;https://blog.jamesdbloom.com/JVMInternals.html#constant_pool&quot;&gt;别人的吧&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;内存-4&quot;&gt;内存&lt;/h4&gt;

&lt;p&gt;它的内存是从方法区的内存里分配的，受到方法区本身内存大小的限制。&lt;/p&gt;

&lt;h4 id=&quot;异常-4&quot;&gt;异常&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;当创建类(Class)或者接口(Interface)时，运行时常量池需要的内存大于方法区剩余的空余内存,抛&lt;strong&gt;&lt;em&gt;OutOfMemoryError&lt;/em&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;补充说明&quot;&gt;补充说明&lt;/h3&gt;

&lt;h4 id=&quot;heap-和-method-area-的逻辑关系&quot;&gt;Heap 和 Method Area 的逻辑关系。&lt;/h4&gt;

&lt;p&gt;可以看看&lt;a href=&quot;https://www.artima.com/insidejvm/ed2/jvm6.html&quot;&gt;The Heap&lt;/a&gt;下面画的几种关系图。 我就先不画了，偷个懒，后面单独写Heap和MethodArea的时候再说。&lt;/p&gt;

&lt;h4 id=&quot;直接内存-direct-memory&quot;&gt;直接内存 (Direct Memory)&lt;/h4&gt;

&lt;p&gt;该内存区域不属于运行时数据区(Runtime Data Areas)，也不在《Java虚拟机规范》的定义中。
  比如开发者可以通过JNI或者NIO的ByteBuffer来调用malloc.&lt;/p&gt;

&lt;h4 id=&quot;nio&quot;&gt;NIO&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;这部分摘自《深入理解JAVA虚拟机(第三版)》。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区 (Buffer)的I/O方式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;这么做避免了在Java堆和Native堆中来回复制数据，能在一些场景中显著提高性能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.geeksforgeeks.org/java-virtual-machine-jvm-stack-area/&quot;&gt;Java Virtual Machine (JVM) Stack Area&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5&quot;&gt;JVMS-Run-Time Data Areas&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/34907497/&quot;&gt;深入理解JAVA虚拟机(第三版)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.baeldung.com/native-memory-tracking-in-jvm&quot;&gt;Native Memory Tracking in JVM&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.artima.com/insidejvm/ed2/index.html&quot;&gt;Inside the Java Virtual Machine&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="Scroll" /><summary type="html">概述</summary></entry><entry><title type="html">JVM Overview</title><link href="http://localhost:4000/JVM-Overview" rel="alternate" type="text/html" title="JVM Overview" /><published>2020-12-26T00:00:00+08:00</published><updated>2020-12-26T00:00:00+08:00</updated><id>http://localhost:4000/JVM-Overview</id><content type="html" xml:base="http://localhost:4000/JVM-Overview">&lt;p&gt;前一阵微信提醒我不要浪费订阅号资源。&lt;/p&gt;

&lt;p&gt;于是就顺手画了一张图回忆JVM，顺便借着这个机会把JVM的知识点系统化一下。&lt;/p&gt;

&lt;p&gt;因为当时先发的微信订阅号，所以这里的内容会跟订阅号略有不同。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lament-z.com/assets/images/JVM/JVM-Overview.jpg&quot; alt=&quot;JVM Overview&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;用法&quot;&gt;用法&lt;/h2&gt;

&lt;p&gt;我特别不擅长背东西，通常需要借助一些手段来帮助记忆。&lt;/p&gt;

&lt;p&gt;对于JVM这种，我用的是看图说话+推理式记忆法，核心思路就是按照逻辑去记忆和推理细节。&lt;/p&gt;

&lt;p&gt;当JVM的模型结构还不熟悉时，可以一边口述逻辑关系，一边画出这个图。&lt;/p&gt;

&lt;p&gt;当可以熟练的画出该图后，可以尝试分模块口述每个模块的功能，甚至每个模块内部的细分结构。&lt;/p&gt;

&lt;p&gt;每一层只回忆当前层的知识，深入讨论放在合适的层面，比如overview时不去回忆什么方法区，只想RuntimeDataArea。&lt;/p&gt;

&lt;p&gt;这样可以在脑内建立一个符合JVM模型/设计逻辑的知识体系，相当于一个索引一样。&lt;/p&gt;

&lt;p&gt;当工作/面试时遇到某些零散知识点的时候，研究明白之后就可以相对精准的补充到合适的维度。&lt;/p&gt;

&lt;p&gt;不至于重演之前用完就忘了的尴尬。&lt;/p&gt;

&lt;h2 id=&quot;一个面试题告诉你什么叫鱼的记忆&quot;&gt;一个面试题告诉你什么叫鱼的记忆&lt;/h2&gt;

&lt;p&gt;这简直就是我鱼的记忆一个典型例子。&lt;/p&gt;

&lt;p&gt;我学习JVM最初主要通过《深入理解JAVA虚拟机》这本书，翻来覆去的看了好多遍，然而昨天朋友发来一道从该书提取出的面试题大致如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
        String str1 = new StringBuilder(&quot;lament&quot;).append(&quot;z&quot;).toString();
        System.out.println(str1);
        System.out.println(str1.intern());
        System.out.println(str1 == str1.intern());


        System.out.println();

        String str2 = new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString();
        System.out.println(str2);
        System.out.println(str2.intern());
        System.out.println(str2 == str2.intern());


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我对此完全没有印象，打开书特意找了一下才发现确实是介绍方法区那一节的一个例子。&lt;/p&gt;

&lt;p&gt;这个例子本身非常有趣，但是其实作为面试题（尤其是问为什么最后一行的输出是false）来考察是不是看过这本书，对我这种鱼的记忆简直太过分了。&lt;/p&gt;

&lt;p&gt;需要注意的是这个例子是与环境强相关的，如果你想自己重现false的情况，可以使用 &lt;em&gt;** Oracle JDK7u / OpenJDK7u HotSpot VM **&lt;/em&gt; 。&lt;/p&gt;

&lt;p&gt;不然你很可能看到两个true XD。&lt;/p&gt;

&lt;p&gt;当然如果你看到这里突然对“字符串常量池”和“String#intern”产生兴趣了，可以看看美团的这一篇&lt;a href=&quot;https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html&quot;&gt;解析&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/34907497/&quot;&gt;深入理解JAVA虚拟机(第三版)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&quot;&gt;The Java® Virtual Machine Specification&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="Scroll" /><summary type="html">前一阵微信提醒我不要浪费订阅号资源。</summary></entry></feed>