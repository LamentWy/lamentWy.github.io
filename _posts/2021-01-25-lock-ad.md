---
layout: post
current: post
title: 几种锁优化简介
navigation: True
tags: [Scroll]
class: post-template
subclass: 'post tag-scroll'
---
## 锁优化  

> 高效并发是从JDK 5升级到JDK 6后一项重要的改进项，HotSpot虚拟机开发团队在这个版本上花 费了大量的资源去实现各种锁优化技术，如适应性自旋(Adaptive Spinning)、锁消除(Lock Elimination)、锁膨胀(Lock Coarsening)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率。

可以看到大部分优化都是针对**阻塞同步**这个最重的操作进行的。

### 自旋锁 & 适应性自旋锁  

阻塞/互斥同步性能问题最大的原因是由于挂起和恢复线程很麻烦，并且很多共享数据的锁定时间很短，可能阻塞线程的挂起恢复还没完成，它锁定就结束了。

针对这种情况，于是就出现了自旋锁，当一个线程持有共享数据时，另一个线程不必挂起，而是原地自旋spinning，这样不会进行挂起和恢复操作。

当然缺点就是自旋时候依然占用着处理器时间，并且自旋操作没有意义，如果多次自旋后依然获取不到锁，还是要挂起。

自旋次数默认为10次，并且可以通过JVM参数 ```-XX: PreBlockSpin ```进行更改。

而适应性自旋锁，就是自旋时间不固定（相对于前面的 单次自旋时间*自旋次数），它的时间取决于前一次在同一个锁上的自旋时间，以及锁的持有者的状态来决定。

如果对于同一个共享资源（上锁的对象），一个线程自旋刚刚成功获取到锁，并且这个线程正在运行，那么JVM会认为该资源的其他等待线程接着自旋也很有可能很快获取到锁，于是JVM会允许这些等待线程进行更多的自旋次数；相反，如果某个共享资源，等待线程基本就没成功获取过锁，那么之后可能直接忽略掉自旋，转为直接挂起。

+ 自旋 Spinning
所谓自旋Spinning，就是让线程自己保持状态原地自己玩一会儿。


### 锁消除  

锁消除是指JVM即时编译器运行时对同步代码进行检测，对于那些不可能存在竞争的共享数据上的锁进行消除。

> 锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可 以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。

由于Java应用中除了开发者自行编写的代码外，Java类库、框架等等代码中是存在很多开发者并不知晓的同步代码的，只要逃逸分析发现代码中的共享资源的引用不会逃逸，并且其他线程永远访问不到他，这部分锁就会被即时编译器消除掉（解释执行时锁还是在的）。

### 锁粗化

原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据 的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。

但是如果一系列的连续操作都对同一个对象反复加锁和 解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

这个时候JVM会把这一堆小锁换成一个包含这些资源的大锁，比如循环里的锁换成循环外的锁。

### 轻量级锁  

在代码即将进入同步块的时候，如果此同步对象没有被锁定(锁标志位为“01”状态)，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的Mark Word的拷贝(官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word)。

然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位(Mark Word的 最后两个比特)将转变为“00”，表示此对象处于轻量级锁定状态。

这时候线程堆栈里存着原来Mark Word的值，而Mark word的现在存的是指向Lock Record的指针。

释放锁的过程也是通过CAS操作进行，指针如果还是指向线程的Lock Record，那么就把之前拷贝的Mark Word信息还给对象头。

说完正常流程来说不正常流程。

加锁过程中的CAS如果失败了，说明有其他线程竞争这个对象，JVM这个时候会先检测对象的Mark Word是不是指向（当前线程的栈中的）Lock Record的指针，如果是，那说明当前线程抢到这个锁了，执行同步块然后释放锁就好了；如果不是那说明这个对象被其他线程先抢走了，这个时候要么自旋一会儿，要么膨胀成重量级锁。

释放锁过程中如果CAS操作失败，说明有其他线程尝试过获取锁，八成都膨胀成重量级锁了，这个时候要释放锁，并且唤醒其他挂起的线程。

#### 性能

轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销;但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。

+ 对象头 Mark Word


![img TODO 对象头，线程的栈帧， 以及整个过程二者的交互图]()

### 偏向锁

> (启用参数-XX:+UseBiased Locking，这是自JDK 6 起HotSpot虚拟机的默认值)

偏向锁也是JDK 6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。

偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志 位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程 的ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作(例如加锁、解锁及对Mark Word的更新操作等)。

一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是 否处于被锁定的状态决定是否撤销偏向(偏向模式设置为“ 0”)，撤销后标志位恢复到未锁定(标志位 为“ 01”)或轻量级锁定(标志位为“ 00”)的状态，后续的同步操作该膨胀膨胀，该解锁解锁。

由于偏向锁没有保存对象头Mark word原本存着的信息（毕竟把CAS都省了），所以对象的hashcode是会丢失的。
Object::hashCode()或者System::identityHashCode(Object)这俩方法实际上返回值是对象的一致性哈希码(Identity Hash Code)，这个值就是存在MarkWord中的HashCode。很多API都是依赖这个值的，所以一但计算过这个哈希的对象，就永远不能进入偏向锁状态，处于该状态的对象如果收到计算这个哈希值的请求，就会立刻退出偏向锁状态，直接膨胀成重量级锁，而重量级锁和轻量级锁都是会保存Mark Word的。

#### 性能  

同样是无竞争的情况越多效率越高。特殊情况下可能关闭之后效率更高。
