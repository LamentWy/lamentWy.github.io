---
layout: post
current: post
title: 线程安全及常见的实现思路(draft)
navigation: True
tags: [Scroll]
class: post-template
subclass: 'post tag-scroll'
---

# 线程安全

当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。

## 五种共享数据的类型

1. 不可变的类型  

  final关键字带来的可见性，保证了只要一个不可变对象（基本数据类型or不可变类的实例）正确的被创建了，那他就是线程安全的。

  当然对于不可变类，Java不能保证它的值不会变，这个要靠类自己的实现确保不会改变，比如String。

2. 绝对线程安全的类型  

  **“绝对线程安全”**类型的共享数据是指：无论在什么情况下，直接使用都不会出意外状况，由于要求过于严格，代价可能非常大。
  JavaAPI中很多线程安全的类都不是绝对线程安全，往往需要增加额外的同步手段，比如java.util.Vector。

3. 相对线程安全的类型
  此类共享数据是指：保证对该数据的单次操作是线程安全的，特殊情况需要调用方通过同步等手段保证正确。
  java.util.Vector 就是相对安全的类型。

4. 线程兼容的类型  
   这类共享数据，本身不是线程安全的，但是调用方可以使用同步手段，让这些数据在并发环境中正常工作。

5. 线程对立的类型  
   无论如何都不能被并发的数据。

## 线程安全的实现思路  

### 互斥同步/阻塞同步  

   互斥同步中，互斥指共享的数据本身是互斥的，同一时刻只能被一个线程（信号量则是一些）访问（主要是写/修改），以此保证多线程同时访问共享数据仍然保持同步。
   由于共享数据是互斥的，其他线程在锁释放前都会被阻塞，所以也叫阻塞同步。

   互斥同步/阻塞同步是一种悲观的并发策略，它假设不加锁就一定会出问题。

#### 互斥的实现方式

TODO

1. 临界区 Critical Section

2. 互斥量 Mutex

3. 信号量 Semaphore

#### 实现互斥同步的几种方式：

##### synchronized块

  先回忆下前面的知识：

  更大范围的原子性保证通过 lock 和 unlock 来实现，JVM提供了 monitorEnter 和 monitorExit 来隐式的使用 lock 和 unlock ，代码中对应的则是 synchronized 关键字。

  主流Java虚拟机实现中，Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免地陷入用户态到核心态的转换中，进行这种状态转换需要耗费很多的处理器时间。

  所以 synchronized 会被编译成 monitorEnter monitorExit 这两条字节码指令，这两个字节码指令都需要一个 reference 类型的参数来指明 要锁定和解锁的对象。如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference;如果没有明确指定，那将根据synchronized修饰的方法类型(如实例方法或类方法)，来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。

      1. synchronized块中的代码，可以被同一线程重复进入，简称可重入。

      2. 释放锁之前无条件阻塞其他线程。其他的线程拿他一点办法没有。

  根据上面的信息可以看出，synchronized块是一种重量级的操作，首先它会阻塞其他线程，这种阻塞会导致大量的状态转换。

##### 重入锁(ReentrantLock)

  由于synchronized块的局限性(只能对引用类型加锁，只能等执行结束or异常中断，不可避免的切换代价)，Java类库提供了java.util.concurrent包，通常被简称为JUC，其中java.util.concurrent.locks.Lock接口便成了Java的另一种全新的互斥同步手段。

  基于Lock接口，用户能够以非块结构(Non-Block Structured)来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面去实现同步。

  重入锁-ReentrantLock就是Lock的一种实现。 与synchronized块一样它是可重入的（就这种锁都带个计数器），但是多了一些高级功能：

  1. 等待可中断
    当持有锁的线程长时间不放弃锁的话，等待线程可以放弃等待，然后去干别的。
    synchronized block 的话，就只能老老实实的等着。

  2. 公平锁  
    所谓公平就是，一个锁释放后，其他等待线程按照先来后到的顺序获取锁。
    重入锁(ReentrantLock) 默认和synchronized块一样都是非公平锁，一个锁释放后，其他在等待的线程谁抢到是谁的。
    不过重入锁(ReentrantLock) 可以通过构造函数的参数来创建成公平的可重入锁。

  3. 锁可以绑定多个条件  
    一个ReentrantLock对象可以绑定多个Condition对象。
    synchronized块 锁对象的wait()和notify()/notifyAll()配合起来实现一个隐含条件，但是多个条件就得多加对应数量的锁。


### 非阻塞同步    

    这种一种乐观的并发策略，这种策略认为不对被共享的数据“加锁”，直接操作也不一定就会出错。
    所以它是先对数据操作，如果这期间共享数据确实没有被其他线程折腾，那就直接成功；如果发生了冲突，那再执行补救措施，比如重试等。

    这种策略中非常重要的两步 操作 和 冲突检测 这两步必须具备原子性，而且需要由硬件指令来保证（软件的话保证它们的原子性就又绕回阻塞同步了），当硬件指令可以保证这两部操作的原子性时，这种策略就成为了可能，Java中给开发者提供的是 CAS(Compare-and-Swap) 指令。

    比如Java类库里的原子整数类型的自增方法  AtomicInteger.incrementAndGet().
    虽然CAS很美好，但是存在ABA问题。
#### ABA问题

  假设 letter = "A"， T1 读到letter的值为A，然后T1做了一些准备工作，做完后又读取letter（还是A）打算给它赋值。这个A是T1第一次读到的A吗？

  T1做准备工作的时候，它不知道有没有一个T2来了，并且T2 把letter的值改为了B，然后又改回了A。

  为了解决ABA问题，它们又给letter加了个时间戳属性，但是比较鸡肋，因为大部分时候ABA问题不会导致并发错误。

### 无同步  

  这种策略就干脆是，我所有的代码都不存在变量被并发访问的情况，即便有一些共享数据但是我把他们都放在同一个线程里(Thread Local Storage)，自然也就无所谓线程安全。    
