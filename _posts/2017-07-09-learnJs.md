---
layout: post
title: Day Five
description: 函数
---

## JavaScript 函数的定义和调用

SampleCode:

```JavaScript
function foo(name) {
  alert('welcome,'+name);
}

foo('lament');
```
> function 定义函数

> foo 函数名

> (name) 参数名

> {......} 函数体

Sample2:
```JavaScript
var foo2 = function (name) {
  alert('这是一个匿名函数,通过变量 '+name+' 调用');
};

foo2('foo2');
```
Sample2是一个匿名函数，通过给变量foo2赋值来调用函数。
__注意使用结尾需要加;，表示赋值语句结束(类似 var name = 'lament';)__

### 向函数传参

JS 的函数允许传入任意个参数，与函数在定义时的参数个数无关.

+ arguments

基于这个特性，JS提供了一个关键字 arguments，它只在函数内部起作用，并且永远指向函数被调用时传入的所有参数.使用方法类似 Array 。

```JavaScript
function foo3(x) {
  alert(x);
  for (var i=0 ; i<arguments.length; i++){
    alert(arguments[i]);
  }
}

foo3(1,2,3,4,5,6,7,8,9,0);
```
+ rest

根据上面的例子可知，arguments[0] 是我们定义的函数时定义的参数 x。

然后arguments[1]开始才是已定义参数 x 之外的参数。

但是当只需要未定义参数时，使用 arguments 的下标访问就很麻烦。

ES6 标准引入了 rest 参数，该类似arguments，但是它只指向未定义的参数。

SampleCode:
```JavaScript
function foo4(a,b,c, ...rest){
  for(var i=0; i<rest.length; i++){
    alert(rest[i]);
  }
}
```
__注意JavaScript引擎有个在行末自动添加分号的机制，return 语句如需多行，务必使用{}将需要 return 的内容包裹起来__


### 变量的作用域

在函数体内部声明的变量，作用域为整个函数体，外部不可调用。

两个不同函数声明了同一个名字的变量，那么变量只在各自函数体内有效。

两个相互嵌套起来的函数，内部函数可以调用外部函数内定义的变量，但外部函数不能调用内部函数的变量。

如果内外函数的变量重名，则遵循从内向外原则，内部函数的变量会屏蔽掉外部函数的同名变量，也就是这种时候内部函数无法调用外部函数定义的同名变量。

+ 变量提升

JavaScript的函数允许函数体内部的变量先使用后声明，原因是JS引擎会先把变量的声明自动提到“最前面”，但是不赋值，可以参考下面代码的效果。

```JavaScript
function foo1(){
  var str1 = 'welcome , '+name;

  alert(str1);
  var name = "lament";

  alert(str1+' again!');
}

foo1(); // welcome , undefined
```

__所以一定先声明且初始化(如果需要)函数所用到的所有变量后，再使用__

+ 全局变量

不在任何函数体内声明的变量就是全局变量，实际上就是JS默认全局对象 window 的一个属性。

```JavaScript
// 该代码来自 廖雪峰 JavaScript教程
'use strict';

var course = 'Learn JavaScript';
alert(course); // 'Learn JavaScript'
alert(window.course); // 'Learn JavaScript'
```
